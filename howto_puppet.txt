# How to search for/install a module (Graphite in this example) using Puppet Forge:

Puppet operates a service called the Puppet Forge (https://forge.puppet.com/), which serves as a repository for Puppet modules. A module nicely packages all the code and data Puppet needs to manage a given aspect in your infrastructure, which is especially helpful when you're dealing with a complex application like Graphite.

The puppet module tool lets you search for modules directly from the command line. 
puppet module search graphite

For Puppet Enterprise, the default modulepath is /etc/puppetlabs/code/environments/production/modules.

The graphite module includes Puppet code that defines a graphite class. In Puppet, a class is simply a named block of Puppet code that defines a set of associated system resources. A class might install a package, customize an associated configuration file for that package, and start a service provided by that package. These are related and interdependent processes, so it makes sense to organize them into a single configurable unit: a class.
While a module can include many classes, it will generally have a main class that shares the name of the module. This main class will often handle the basic installation and configuration of the primary component the module is designed to manage.
The graphite class contains the instructions Puppet needs to set up Graphite, but you still need to tell Puppet where and how you want it to apply the class across your infrastructure. This process of matching classes to nodes is called classification.

NOTE: Puppet Approved modules adhere to a set of Puppet specifications for style, documentation, and semantic versioning, along with other best practices standards. Puppet Supported modules are rigorously tested for compatibility with Puppet Enterprise and are fully covered by Puppet's support team.

# Install a puppet module:
puppet module install dwerder-graphite -v 5.16.1

When you ran the puppet module command, Puppet retrieved the graphite module from Forge and placed it in the Puppet master's modulepath. The modulepath is where Puppet will look to find Puppet classes and other files and resources made available by any modules you download or create. For Puppet Enterprise, the default modulepath is /etc/puppetlabs/code/environments/production/modules.


# Use the PE console to define a node group, adding the Learning VM to the group, and classifying the group with the graphite class.
Of course, you could use a command like ifconfig to find this, but let's do it the Puppet way. Puppet uses a tool called facter to collect facts about a system and make them available at catalog compilation. This is how it knows, for example, whether it's on Ubuntu and needs to use apt-get or CentOS and needs yum. You'll learn more about facts and conditionals in Puppet later. For now, we can use facter in the command-line to determine the Learning VM's IP address.
facter ipaddress

Open a web browser on your host machine and go to https://<IPADDRESS>, where <IPADDRESS> is the Learning VM's IP address. (Be sure to include the s in https!)
When prompted, use the following credentials to log in:

    username: admin

    password: puppetlabs


# Create a node group

Now that you have access to the PE console, we'll walk you through the steps to classify the "learning.puppetlabs.vm" node (i.e. the Learning VM) with the graphite class.
First, create a Learning VM node group. Node groups allow you to segment all the nodes in your infrastructure into separately configurable groups based on the node's certname and all information collected by the facter tool.
Click on Classification in the console navigation bar. It may take a moment to load.

# Add a class

When you installed the dwerder-graphite module from the forge, it made the graphite class available in the console.
Under the Classes tab in the interface for the Learning VM node group, find the Class name text box. When you click in 1
the classes textbox and begin typing, the graphite class should autofill. If it does not, click the Refresh button near the top right of the classes interface and wait a moment before trying again. 

Before you apply the class, there are a few parameters you'll want to set.
We already have an Apache server configured to our liking on the Learning VM, so we can tell the graphite class it doesn't need to bother setting up its own server.
There are also some compatibility issues with the latest Django version. The author of this graphite module has made it easy to get around this problem by picking our own compatible Django version to use. (Keep this in mind when you start writing your own modules!)

Set the parameters, as follows:

    gr_web_server = none
    gr_django_pkg = django
    gr_django_provider = pip
    gr_django_ver = "1.5"

Note that the gr_django_ver parameter takes a string, not float value, so it must be wrapped in quotes for Puppet to parse it correctly.
Double check that you have clicked the Add parameter button for all of your parameters, then click the Commit 5 changes button in the bottom right of the console window to commit your changes.

# Run Puppet

Now that you have classified the learning.puppetlabs.vm node with the graphite class, Puppet knows how the system should be configured, but it won't make any changes until a Puppet run occurs.
By default, the Puppet agent daemon runs in the background on all nodes you manage with Puppet. Every 30 minutes, the Puppet agent daemon requests a catalog from the Puppet master. The Puppet master parses all the classes applied to that node, builds the catalog to describe how the node is supposed to be configured, and returns this catalog to the node's Puppet agent. The agent then applies any changes necessary to bring the node in line with the state described by the catalog.

To avoid surprises, however, we've disabled these scheduled runs on the Learning VM. Instead, we'll be using the puppet agent tool to trigger runs manually.
As you're working through this Quest Guide, keep in mind that the Learning VM is running both a Puppet master and a Puppet agent. This is a bit different than what you'd see in a typical architecture, where a single Puppet master would serve a collection of Puppet agent nodes. The Puppet master is where you keep all your Puppet code. Earlier when you used the puppet module tool to install the graphite module, that was a task for the Puppet master. When you want to manually trigger a Puppet run with the puppet agent tool, that's a command you would use on an agent node, not the master.
So put on your agent hat and trigger a Puppet run:

puppet agent --test

Graphite is a complex piece of software with many dependencies, so this may take a while to run. After a brief delay, you will see text scroll by in your terminal indicating that Puppet has made all the specified changes to the Learning VM.

You can also check out the Graphite console running on port 90. (http://<IPADDRESS>:90)
We've selected a few parameters as an example. Paste the following path after the Graphite console URL to try it out:
/render/?width=586&height=308&_salt=1430506380.148&from=-30minutes&fontItalic=false&fontName=Courier&target=alias(carbon.agents.learning_puppetlabs_vm-a.cpuUsage%2C"CPU")&target=alias(secondYAxis(carbon.agents.learning_puppetlabs_vm-a.memUsage)%2C"Memory")&majorGridLineColor=C0C0C0&minorGridLineColor=C0C0C0
Note that Graphite has only been running for a few minutes, so it may not yet have much data to chart. If you wait a minute and refresh the page in your browser, you will see the graph update with new data.
e.g. http://192.168.1.12:90/render/?width=586&height=308&_salt=1430506380.148&from=-30minutes&fontItalic=false&fontName=Courier&target=alias(carbon.agents.learning_puppetlabs_vm-a.cpuUsage%2C%22CPU%22)&target=alias(secondYAxis(carbon.agents.learning_puppetlabs_vm-a.memUsage)%2C%22Memory%22)&majorGridLineColor=C0C0C0&minorGridLineColor=C0C0C0



Resources Quest
Quest objectives

    Understand how resources on the system are modeled in Puppet's Domain Specific Language (DSL).
    Use Puppet to inspect resources on your system.
    Use the Puppet Apply tool to make changes to resources on your system.
    Learn about the Resource Abstraction Layer (RAL).

Before you go on to learn the more complex aspects of Puppet, you should start with a solid understanding of resources, the fundamental building blocks of Puppet's declarative modeling syntax.
In this quest, you will learn what resources are and how to inspect and modify them with Puppet command-line tools.

Taking common tasks and abstracting away the complexities and pitfalls doesn't just make those tasks themselves easier, it gives you the stable, repeatable, and testable foundation you need to build something new.
For Puppet, this foundation is a system called the resource abstraction layer. Puppet interprets any aspect of your system configuration you want to manage (users, files, services, and packages, to give some common examples) as a unit called a resource. Puppet knows how to translate back and forth between the resource syntax and the 'native' tools of the system it's running on. Ask Puppet about a user, for example, and it can represent all the information about that user as a resource of the user type. Of course, it's more useful to work in the opposite direction. Describe how you want a user resource to look, and Puppet can go out and make all the changes on the system to actually create or modify a user to match that description.
The block of code that describes a resource is called a resource declaration. These resource declarations are written in Puppet code, a Domain Specific Language (DSL) based on Ruby.


Puppet's Domain Specific Language

A good understanding of the Puppet DSL is a key first step in learning how to use Puppet effectively. While tools like the PE console give you quite a bit of power to make configuration changes at a level above the code implementation, it always helps to have a solid understanding of the Puppet code under the hood.
Puppet's DSL is a declarative language rather than an imperative one. This means that instead of defining a process or set of commands, Puppet code describes (or declares) only the desired end state. With this desired state described, Puppet relies on built-in providers to handle implementation.
One of the points where there is a nice carry over from Ruby is the hash syntax. It provides a clean way to format this kind of declarative model, and is the basis for the resource declarations

As we mentioned above, a key feature of Puppet's declarative model is that it goes both ways; that is, you can inspect the current state of any existing resource in the same syntax you would use to declare a desired state.

Use the puppet resource tool to take a look at your root user account. The syntax of the command is: puppet resource \ \.

puppet resource user root 

This resource declaration syntax is composed of three main components:

    Type
    Title
    Attribute value pairs

Resource Type

You'll get used to the resource syntax as you use it, but for this first look we'll go through the example point by point.

We'll start with the first line first:

  user { 'root':
    ...
  }

The word user, right before the curly brace, is the resource type. The type represents the kind of thing that the resource describes. It tells Puppet how to interpret the rest of the resource declaration and what kind of providers to use for managing the underlying system details.

Puppet includes a number of built-in resource types, which allow you to manage aspects of a system. Below are some of the core resource types you'll encounter most often:

    user A user
    group A user group
    file A specific file
    package A software package
    service A running service
    cron A scheduled cron job
    exec An external command
    host A host entry

If you are curious to learn about all of the built-in resources types available, see the Type Reference Document or try the command puppet describe --list.

Resource Title

Take another look at the first line of the resource declaration.

  user { 'root':
    ...
  }

The single quoted word 'root' just before the colon is the resource title. Puppet uses the resource title as its own internal unique identifier for that resource. This means that no two resources of the same type can have the same title.

In our example, the resource title, 'root', is also the name of the user we're inspecting with the puppet resource command. Generally, a resource title will match the name of the thing on the system that the resource is managing. A package resource will usually be titled with the name of the managed package, for example, and a file resource will be titled with the full path of the file.

Keep in mind, however, that when you're creating your own resources, you can set these values explicitly in the body of a resource declaration instead of letting them default to the resource title. For example, as long as you explicitly tell Puppet that a user resource's name is 'root', you can actually give the resource any title you like. ('superuser', maybe, or even 'spaghetti') Just because you can do this, though, doesn't mean it's generally a good idea! Unless you have a good reason to do otherwise, letting Puppet do its defaulting magic with titles will save you typing and make your Puppet code more readable.

Attribute Value Pairs
Now that we've covered the type and title, take a look at the body of the resource declaration.

user { 'root':
  ensure           => present,
  comment          => 'root',
  gid              => '0',
  home             => '/root',
  password         => '$1$jrm5tnjw$h8JJ9mCZLmJvIxvDLjw1M/',
  password_max_age => '99999',
  password_min_age => '0',
  shell            => '/bin/bash',
  uid              => '0',
}

After the colon in that first line comes a hash of attributes and their corresponding values. Each line consists of an attribute name, a => (pronounced 'hash rocket'), a value, and a final comma. For instance, the attribute value pair home => '/root', indicates that root's home is set to the directory /root.

So to bring this all together, a resource declaration will match the following pattern:

type {'title':
    attribute => 'value',
}

Note that the comma at the end of the final attribute value pair isn't required by the parser, but it is best practice to include it for the sake of consistency. Leave it out, and you'll inevitably forget to insert it when you add another attribute value pair on the following line!

Of course, the real meat of a resource is in these attribute value pairs. You can't do much with a resource without a good understanding of its attributes. The puppet describe command makes this kind of information easily available from the command line.

Use the 'puppet describe' tool to get a description of the user type, including a list of its parameters.

puppet describe user | less

(You can use the jk key mapping or the arrow keys to scroll, and q to exit less.)


Puppet Apply

You can use the puppet apply tool with the -e (--execute) flag to execute a bit of Puppet code. Though puppet apply -e is limited to one-off changes, it's a great tool for tests and exploration.

In this task, you'll create a new user called galatea. Puppet uses reasonable defaults for unspecified user attributes, so all you need to do to create a new user is set the ensure attribute to present. This present value tells Puppet to check if the resource exists on the system, and to create the specified resource if it does not.

puppet apply -e "user { 'galatea': ensure => present, }"

Use the puppet resource tool to take a look at user galatea. Type the following command:

puppet resource user galatea

Notice that while the root user had a comment attribute, Puppet hasn't created one for your new user. As you may have noticed looking over the puppet describe entry for the user type, this comment is generally the full name of the account's owner.

Though you could add a comment with the puppet apply -e, you'd have to cram the whole resource declaration into one line, and you wouldn't be able to see the current state of the resource before making your changes. Luckily, the puppet resource tool can also take a -e flag. This will drop the current state of a resource into a text editor where you can make any changes you like.

Let's give it a try:

puppet resource -e user galatea

You should see the same output for this resource as before, but this time it will be opened in a text editor (Vim, by default). To add a comment attribute, insert a new line to the resource's list of attribute value pairs. (If you're not used to Vim, note that you must use the i command to enter insert mode before you can insert text.)

comment => 'Galatea of Cyprus',


Quest: Manifests and classes
Quest objectives

    Understand the concept of a Puppet manifest
    Construct and apply manifests to manage resources
    Understand what a class means in Puppet's Language
    Learn how to use a class definition
    Understand the difference between defining and declaring a class

In this quest, we're going to cover two key Puppet concepts that will help you organize and implement your resource declarations: classes and manifests. Proper use of classes and manifests is the first step towards writing testable and reusable Puppet code.


Manifests

At its simplest, a manifest is nothing more than some puppet code saved to a file with the .pp extension. It's the same stuff you saw using the puppet resource tool and applied with the puppet apply tool. Easy enough, but it's where you put a manifest and what you put in it that really matter.

Much of this organizational structure, both in terms of a manifest's content and its location on the puppet master's filesystem, is related to Puppet classes. 

Classes

In Puppet's DSL a class is a named block of Puppet code. The class is the next level of abstraction above a resource. A class declares a set of resources related to a single system component.

We'll cover class parameters in depth in a later quest. For now, we'll focus on how the abstraction provided by classes allows you to manage complex sets of resources in terms of a single function they serve.

Using a Puppet class requires two steps. First, you must define it by writing a class definition and saving it to a manifest file. Puppet will parse this manifest and remember your class definition. The class can then be declared to apply the resource declarations it contains to a node in your infrastructure.

There are several ways to tell Puppet where and how to apply classes to nodes. You already saw the PE Console's node classifier in the Power of Puppet quest, and we'll discuss other methods of node classification in a later quest. For now we'll show you how to write class definitions and use test manifests to declare these classes locally.

One more note on the topic of classes: In Puppet, classes are singleton, which means that a class can only be declared once on a given node. In this sense, Puppet's classes are different than the kind of classes you may have encountered in object-oriented programming, which are often instantiated multiple times. Declaring a class multiple times could give Puppet conflicting instructions for how to manage resources on a system.

We've already prepared a cowsayings module directory in Puppet's modulepath, and included two subdirectories: manifests and examples. Before getting started writing manifests, change directories to save yourself some typing:

cd /etc/puppetlabs/code/environments/production/modules

Cowsay

Let's start with cowsay. To use the cowsay command, you need to have the cowsay package installed. You can use a package resource to handle this installation, but you don't want to put that resource declaration just anywhere.

To keep things tidy, we'll create a cowsay.pp manifest, and within that manifest we'll define a class that can manage the cowsay package.

First, create a simple module structure to contain your manifests. (We'll cover this structure in more depth in the next quest.)
mkdir -p cowsayings/{manifests,examples}

Use vim to create a cowsay.pp manifest:
vim cowsayings/manifests/cowsay.pp

Enter the following class definition, then save and exit (:wq):

class cowsayings::cowsay {
  package { 'cowsay':
    ensure   => present,
    provider => 'gem',
  }
}

Now that you're working with manifests, you can validate your code before you apply it. Use the puppet parser tool to check the syntax of your new manifest:

puppet parser validate cowsayings/manifests/cowsay.pp

The parser will return nothing if there are no errors. If it does detect a syntax error, open the file again and fix the problem before continuing.

If you try to directly apply your new manifest, nothing on the system will change. (Give it a shot if you like.) This is because you have defined a cowsay class, but haven't declared it anywhere. Puppet knows that the cowsay class contains a resource declaration for the cowsay package, but hasn't yet been told to do anything with it.

If you were going to apply this code to your production infrastructure, you would use the console's node classifier to classify any nodes that needed cowsay installed with the cowsay with your cowsay class. As you're working on a module, however, it's useful to apply a class directly. By convention, these test manifests are kept in an examples directory. (You may also sometimes see these manifests in the tests directory.)

To actually declare the class, create a cowsay.pp test in the examples directory.
vim cowsayings/examples/cowsay.pp

In this manifest, declare the cowsay class with the include keyword.
include cowsayings::cowsay

Save and exit.

Before applying any changes to your system, it's always a good idea to use the --noop flag to do a 'dry run' of the Puppet agent. This will compile the catalog and notify you of the changes that Puppet would have made without actually applying any of those changes to your system.

puppet apply --noop cowsayings/examples/cowsay.pp

If your dry run looks good, go ahead and run puppet apply again without the --noop flag. If everything went according to plan, the cowsay package is now installed on the Learning VM. Give it a try!

cowsay Puppet is awesome!

Fortune

But this module isn't just about cowsay; it's about cow sayings. With the fortune package, you can provide your cow with a whole database of wisdom.

Create a new manifest for your fortune class definition:
vim cowsayings/manifests/fortune.pp

Write your class definition here:

class cowsayings::fortune {
  package { 'fortune-mod':
    ensure => present,
  }
}

Again, you'll want to validate your new manifests syntax with the puppet parser validate command. When everything checks out, you're ready to make your test manifest:
vim cowsayings/examples/fortune.pp

As before, use include to declare your cowsayings::fortune class. 
include cowsayings::fortune

Save and exit.

puppet apply --noop cowsayings/examples/fortune.pp

Then apply it for real:
puppet apply cowsayings/examples/fortune.pp

Now that you have both packages installed, you can use them together. Try piping the output of the fortune command to cowsay:

fortune | cowsay



Main class: init.pp

Often a module will gather several classes that work together into a single class to let you declare everything at once.

Before creating the main class for cowsayings, however, a note on scope. You may have noticed that the classes you wrote for cowsay and fortune were both prepended by cowsayings::. When you declare a class, this scope syntax tells Puppet where to find that class; in this case, it's in the cowsayings module.

For the main class of a module, things are a little different. The main class shares the name of the module itself, but instead of following the pattern of naming the manifest for the class it contains, Puppet recognizes the special file name init.pp for the manifest that will contain a module's main class.

So to contain your main cowsayings class, create an init.pp manifest in the cowsayings/manifests directory:

vim cowsayings/manifests/init.pp

Here, you'll define the cowsayings class. Within it, use the same include syntax you used in your tests to declare the cowsayings::cowsay and cowsayings::fortune classes.

class cowsayings {
  include cowsayings::cowsay
  include cowsayings::fortune
}

Save the manifest, and check your syntax with the puppet parser tool.

puppet parser validate cowsayings/manifests/init.pp

At this point, you already have both packages you want installed on the Learning VM. Applying the changes again wouldn't actually do anything. For the sake of testing, you can use the puppet resource tool to delete them so you can try out the functionality of your new cowsayings class:

puppet resource package fortune-mod ensure=absent
puppet resource package cowsay ensure=absent provider=gem

Next, create a test for the init.pp manifest in the examples directory.
vim cowsayings/examples/init.pp

Here, just declare the cowsayings class:
include cowsayings

Good. Now that the packages are gone, do a --noop first, then apply your cowsayings/examples/init.pp test.
puppet parser validate cowsayings/examples/init.pp
puppet apply --noop cowsayings/examples/init.pp
puppet apply cowsayings/examples/init.pp

We covered a lot in this quest. We promised manifests and classes, but you got a little taste of how Puppet modules work as well.

A class is a collection of related resources and other classes which, once defined, can be declared as a single unit. Puppet classes are also singleton, which means that unlike classes in object oriented programming, a Puppet class can only be declared a single time on a given node.

A manifest is a file containing Puppet code, and appended with the .pp extension. In this quest, we used manifests in the ./manifests directory each to define a single class, and used a corresponding test manifest in the ./examples directory to declare each of those classes.

There are also a few details about classes and manifests we haven't gotten to just yet. As we mentioned in the Power of Puppet quest, for example, classes can also be declared with parameters to customize their functionality.


Modules Quest
Quest objectives

    Understand the purpose of Puppet modules
    Learn the module directory structure
    Write and test a simple module

In short, a Puppet module is a self-contained bundle of all the Puppet code and other data needed to manage some aspect of your configuration. In this quest, we'll go over the purpose and structure of Puppet modules, before showing you how to create your own.

Modules allow you to organize your Puppet code into units that are testable, reusable, and portable, in short, modular. This means that instead of writing Puppet code from scratch for every configuration you need, you can mix and match solutions from a few well-written modules. And because these modules are separate and self-contained, they're much easier to test, maintain, and share than a collection of one-off solutions.

At their root, modules are little more than a structure of directories and files that follow Puppet's naming conventions. The module file structure gives Puppet a consistent way to locate whatever classes, files, templates, plugins, and binaries are required to fulfill the function of the module.

Modules and the module directory structure also provide an important way to manage scope within Puppet. Keeping everything nicely tucked away in its own module means you have to worry much less about name collisions and confusion.

Finally, because modules are standardized and self-contained, they're easy to share. Puppet Labs hosts a free service called the Forge where you can find a wide array of modules developed and maintained by others.

All modules accessible by your Puppet Master are located in the directories specified by the modulepath variable in Puppet's configuration file.

You can find the modulepath on your puppet master by running the puppet master command with the --configprint flag and the modulepath argument:
puppet master --configprint modulepath

A module consists of a pre-defined structure of directories that help Puppet reliably locate the module's contents.

Use the the puppet module list command to see what modules are already installed. You'll probably recognize some familiar names from previous quests.

To get a clear picture of the directory structure of the modules here, you can use a couple of flags with the tree command to limit the output to directories, and limit the depth to two directories.

tree -L 2 -d /etc/puppetlabs/code/environments/production/modules/

/etc/puppetlabs/code/environments/production/modules/
├── cowsayings
│   ├── manifests
│   └── examples
└── graphite
    ├── manifests
    ├── spec
    └── templates
    
Each of the standardized subdirectory names you see tells Puppet users and Puppet itself where to find each of the various components that come together to make a complete module.

You've already had a chance to play with the user and package resources in previous quests, so this time we'll focus on the file resource type. The file resource type is also a nice example for this quest because Puppet uses some URI abstraction based on the module structure to locate the sources for files.

The module you'll make in this quest will manage some settings for Vim, the text editor you've been using to write your Puppet code. Because the settings for services and applications are often set in a configuration file, the file resource type can be very handy for managing these settings.

Change your working directory to the modulepath if you're not already there.

cd /etc/puppetlabs/code/environments/production/modules

The top directory will be the name you want for the module. In this case, let's call it "vimrc." Use the mkdir command to create your module directory:

mkdir vimrc

Now you need three more directories, one for manifests, one for examples, and one for files.

mkdir vimrc/{manifests,examples,files}

If you use the tree vimrc command to take a look at your new module, you should now see a structure like this:

vimrc
├── files
├── manifests
└── examples

# Managing files

We've already set up the Learning VM with some custom settings for Vim. Instead of starting from scratch, you can copy the existing .vimrc file into the files directory of your new module. Any file in the files directory of a module in the Puppet master's modulepath will be available to client nodes through Puppet's built-in fileserver.

Copy the existing .vimrc file to your module's files directory:

cp ~/.vimrc vimrc/files/vimrc

Once you've copied the file, open so you can make an addition.

vim vimrc/files/vimrc

We'll keep things simple. By default, line numbering is disabled. Add the following line to the end of the file to tell Vim to turn on line numbering.

set number

Save and exit.


Now that your source file is ready, you need to write a manifest to tell puppet what to do with it.

Remember, the manifest that includes the main class for a module is always called init.pp. Create the init.pp manifest in your module's manifests directory.

vim vimrc/manifests/init.pp

The Puppet code you put in here will be pretty simple. You need to define a class vimrc, and within it, make a file resource declaration to tell Puppet to take the vimrc/files/vimrc file from your module and use Puppet's file server to push it out to the specified location.

In this case, the .vimrc file that defines your Vim settings lives in the /root directory. This is the file you want Puppet to manage, so its full path (i.e. /root/.vimrc) will be the title of the file resource you're declaring.

This resource declaration will then need two attribute value pairs.

First, as with the other resource types you've encountered, ensure => present, would tell Puppet to ensure that the entity described by the resource exists on the system. However, because Linux uses files for both "normal" files and directories, we'll want to use the more explicit ensure => file, instead.

Second, the source attribute tells Puppet what the managed file should actually contain. The value for the source attribute should be the URI of the source file.

All Puppet file server URIs are structured as follows:

puppet://{server hostname (optional)}/{mount point}/{remainder of path}

However, there's some URI abstraction magic built in to Puppet that makes these URIs more concise.

First, the optional server hostname is nearly always omitted, as it defaults to the hostname of the Puppet master. Unless you need to specify a file server other than the Puppet master, your file URIs should begin with a triple forward slash, like so: puppet:///.

Second, nearly all file serving in Puppet is done through modules. Puppet provides a couple of shortcuts to make accessing files in modules simpler. First, Puppet treats modules as a special mount point that will point to the Puppet master's modulepath. So the first part of the URI will generally look like puppet:///modules/

Finally, because all files to be served from a module must be kept in the module's files directory, this directory is implicit and is left out of the URI.

So while the full path to the vimrc source file is /etc/puppetlabs/code/environments/production/modules/vimrc/files/vimrc, Puppet's URI abstraction shortens it to /modules/vimrc/vimrc. Combined with the implicit hostname, then, the attribute value pair for the source URI is:

source => 'puppet:///modules/vimrc/vimrc',

Putting this all together, your init.pp manifest should contain the following:

class vimrc {
  file { '/root/.vimrc':
    ensure => file,
    source => 'puppet:///modules/vimrc/vimrc',
  }
}

Save the manifest, and use the puppet parser tool to validate your syntax:

puppet parser validate vimrc/manifests/init.pp

Test your module

Remember, this manifest defines the vimrc class, but you'll need to declare it for it to have an effect. That is, we've described what the vimrc class is, but you haven't told Puppet to actually do anything with it.

To test the vimrc class, create a manifest called init.pp in the vimrc/examples directory.

vim vimrc/examples/init.pp

All you'll do here is declare the vimrc class with the include directive.

include vimrc

Apply the new manifest with the --noop flag. If everything looks good, drop the --noop and apply it for real.

puppet apply --noop vimrc/examples/init.pp

puppet apply vimrc/examples/init.pp

You'll see something like the following:

Notice: /Stage[main]/Vimrc/File[/root/.vimrc]/content: content changed
'{md5}99430edcb284f9e83f4de1faa7ab85c8' to
'{md5}f685bf9bc0c197f148f06704373dfbe5'

When you tell Puppet to manage a file, it compares the md5 hash of the target file against that of the specified source file to check if any changes need to be made. Because the hashes did not match, Puppet knew that the target file did not match the desired state, and changed it to match the source file you had specified.

To see that your line numbering settings have been applied, open a file with Vim. You should see the number of each line listed to the left.


NTP Quest
Quest objectives

    Use the puppet module tool to find and install modules on the Puppet Forge
    Learn how you can use the site.pp manifest to classify nodes.
    Use class parameters to adjust variables in a class as you declare it.

When you use a publicly available module, you're often getting code that has already been tested and deployed across hundreds or thousands of other users' infrastructures.

Furthermore, using Puppet Supported and Puppet Approved modules adds another layer of validation and reliability.

Keep in mind, though, that no matter whose code you're using, relying on external checks is no substitute for your own thorough review and testing of anything you're putting into production!

In this quest, you'll learn how you can use an existing module from the Puppet Forge to manage an important service on your machine: NTP.

Package/File/Service

We'll show you how to install and deploy the NTP module.

 first, take a look at the current state of your system. This way, you'll be able to keep track of what Puppet changes and understand why the NTP module does what it does.

To get the NTP service running, there are three key resources that Puppet will manage. The puppet resource tool can show you the current state of each of these resources.

First, check the state of the NTP package:

puppet resource package ntp

check the NTP configuration file:

puppet resource file /etc/ntp.conf

finally, see if the Network Time Protocol Daemon (NTPD) service is running:

puppet resource service ntpd

You'll see that the NTP package is purged, that the configuration file is absent, and that the ntpd service is 'stopped'.

As you continue to work with Puppet, you'll find that this package/file/service pattern is very common. These three resource types correspond to the common sequence of installing a package, customizing that package's functionality with configuration files, and starting the service provided by that package.

The package/file/service pattern also describes the typical relationships of dependency among these three resources: a well-written class will define these relationships, telling Puppet to restart the service if the configuration file has been modified, and re-create the configuration file when the package is installed or updated. You'll be working with an existing module in this quest, so these dependencies are already taken care of; we'll get into the specifics of how they can be managed in a later quest.

Installation

Before you classify the Learning VM with the NTP class, you'll need to install the NTP module from the Forge. While the module itself is called ntp, recall that modules in the Forge are prefixed by the account name of the associated user. So to get the Puppet Labs NTP module, you'll specify puppetlabs-ntp. When you look at the module saved to the modulepath on your Puppet master, however, it will be named ntp. Keep this in mind, as trying to install multiple modules of the same name can lead to conflicts!

Use the Puppet module tool to install the Puppet Labs ntp module. (If you've already installed the modules from the cache, this task should already be marked as complete and you can skip this step.)

puppet module install puppetlabs-ntp

This command tells the Puppet module tool to fetch the module from the Puppet Forge and place it in Puppet's modulepath: /etc/puppetlabs/code/environments/production/modules.

Classification with the site.pp manifest

Now that the NTP module is installed, all the included classes are available to use in node classification.

In the Power of Puppet quest, you learned how to classify a node with the PE Console. In this quest, we introduce another method of node classification: the site.pp manifest.

site.pp is the first manifest the Puppet agent checks when it connects to the master. It defines global settings and resource defaults that will apply to all nodes in your infrastructure. It is also where you will put your node definitions (sometimes called node statements).

A node definition is the code-defined equivalent of the node group you saw in the Power of Puppet quest.

node 'learning.puppetlabs.vm' {
  ...
}

Because it's more amenable to monitoring with the Learning VM quest tool, we'll be primarily using this site.pp method of classification in this Quest Guide. What you will learn about node definitions and class declarations applies to whatever methods of classification you decide to use later, including the PE Console node classifier.

Open the site.pp manifest in your text editor.

vim /etc/puppetlabs/code/environments/production/manifests/site.pp

Skip to the bottom of the file. (You can use the vim shortcut G)

You'll see a default node definition. This is a special node definition that Puppet will apply to any node that's not specifically included in any other node definition.

We only want our changes to apply to the Learning VM, however, so we'll put our ntp class declaration in a new learning.puppetlabs.vm node block.


node 'learning.puppetlabs.vm' {
  include ntp
}

Note that triggering a Puppet run with the puppet agent tool is useful for learning and testing, but that in a production environment you would want to let the Puppet agent run as scheduled, every 30 minutes, by default. Because you'll be running Puppet right after making changes to the site.pp manifest, Puppet may not have a chance to refresh its cache. If your changes to the site.pp manifest aren't reflected in a Puppet run triggered by the puppet agent -t command, try running the command again.

Test the site.pp manifest with the puppet parser validate command, and trigger a Puppet run.

puppet agent -t

Once the Puppet run is complete, use the Puppet resource tool to inspect the ntpd service again. If the class has been successfully applied, you will see that the service is running.
Syncing up

To avoid disrupting processes that rely on consistent timing, the ntpd service works gradually. It adds or removes a few microseconds to each tick of the system clock so as to slowly bring it into synchronization with the NTP server.

If you like, run the ntpstat command to check on the synchronization status. Don't worry about waiting to get synchronized. Because the Learning VM is virtual, its clock will probably be set based on the time it was created or last suspended. It's likely to be massively out of date with the time server, and it may take half an hour or more to get synchronized!

puppet resource file /etc/ntp.conf
puppet resource service ntpd  # Doesn't work!

Class defaults and class parameters

The ntp class includes default settings for most of its parameters. The include syntax you used let you concisely declare the class without modifying these defaults.

One of these defaults, for instance, tells Puppet which time servers to include in the NTP configuration file. To see what servers were specified by default, you can check the configuration file directly. Enter the command:

grep server /etc/ntp.conf

You'll see a list of the default servers:

server 0.centos.pool.ntp.org
server 1.centos.pool.ntp.org
server 2.centos.pool.ntp.org

These ntp.org servers aren't actually time servers themselves; rather, they're access points that will pass you on to one of a pool of public timeservers. Most servers assigned through the ntp.org pool are provided by volunteers running NTP as an extra service on a mail or web server.

While these work well enough, you'll get more accurate time and use less network resources if you pick public timeservers in your area.

To manually specify which timeservers your NTPD service will poll, you'll need to override the default ntp.org pool servers set by the NTP module.

This is where Puppet's class parameters come in. Class parameters provide a method to set variables in a class as it's declared. The syntax for parameterized classes looks similar to the syntax for resource declarations. Have a look at the following example:


class { 'ntp':
  servers => [
    'nist-time-server.eoni.com',
    'nist1-lv.ustiming.org',
    'ntp-nist.ldsbc.edu'
  ]
}

The servers parameter in our class declaration takes a list of servers as a value, not just one. This list of values, separated by commas (,) and wrapped in brackets ([]), is called an array. Arrays allow you assign a list of values to a single variable or attribute.

In your site.pp, replace the include ntp line with a parameterized class declaration based on the example above. Use the servers from the example, or, if you know of a nearer timeserver, include that. You should always specify at least three timeservers for NTP to function reliably. You might, for instance, include two from the ntp.org pool and one known nearby timeserver.

vim /etc/puppetlabs/code/environments/production/manifests/site.pp
puppet parser validate /etc/puppetlabs/code/environments/production/manifests/site.pp
puppet agent -t

Once you've made your changes to the site.pp manifest and used the puppet parser tool to validate your syntax, use the puppet agent tool to trigger a Puppet run.

You will see in the output that Puppet has changed the /etc/ntp.conf file and triggered a refresh of the ntpd service.


MySQL Quest

Quest Objectives

    Install and configure a MySQL server.
    Add a MySQL user, add a database, and grant permissions.

The module lets you install and configure both server and client MySQL instances, and extends Puppet's standard resource types to let you manage MySQL users, grants, and databases with Puppet's standard resource syntax.

Server install

Before getting started configuring your MySQL server installation, fetch the puppetlabs-mysql module from the Puppet Forge with the puppet module tool. 

puppet module install puppetlabs-mysql

With this module installed in the Puppet master's module path, all the included classes are available to classify nodes.

Now we'll edit the site.pp to classify the Learning VM with the MySQL server class.

vim /etc/puppetlabs/code/environments/production/manifests/site.pp

If you completed the NTP quest, you will already have a node declaration for the learning.puppetlabs.vm certname. If not, create it now:

Within that node block, you can declare your ::mysql::server class and set its parameters. For this example, we'll specify a root password and set the server's max connections to '1024'. (You may notice that the formatting in vim is a bit funky when typing or pasting nested hashes. You can disable this formatting with the :set paste command in vim.)

node 'learning.puppetlabs.vm' {
  class { '::mysql::server':
    root_password    => 'strongpassword',
    override_options => {
      'mysqld' => { 'max_connections' => '1024' }
    },
  }
}

Notice that in addition to standard parameters like the root_password, the class takes a override_options as a hash, which you can use to address any configuration options you would normally set in the /etc/my.cnf file. Using a hash lets you manage these settings without requiring each to be written into the class as a separate parameter. The structure of the override_options hash is analogous to the [section], var_name = value syntax of a my.cnf file.

Use the puppet parser validate tool to check your syntax, then trigger a puppet run:

puppet agent -t

If you want to check out your new database, you can connect to the MySQL monitor with the mysql command, and exit with the \q command.

To see the result of the 'max_connections' override option you set, use less to view the /etc/my.cnf.d/server.cnf file:

less /etc/my.cnf.d/server.cnf

And you'll see that Puppet translated the hash into appropriate syntax for the MySQL configuration file:

[mysqld]
...
max_connections = 1024


Scope

It was easy enough to use Puppet to install and manage a MySQL server. The puppetlabs-mysql module also includes a bunch of classes that help you manage other aspects of your MySQL deployment.

These classes are organized within the module directory structure in a way that matches Puppet's scope syntax. Scope helps to organize classes, telling Puppet where to look within the module directory structure to find each class. It also separates namespaces within the module and your Puppet manifests, preventing conflicts between variables or classes with the same name.

Take a look at the directories and manifests in the MySQL module. Use the tree command with a filter to include only .pp manifest files:

tree -P "*.pp" /etc/puppetlabs/code/environments/production/modules/mysql/manifests/ 

You'll see something like the following:

/etc/puppetlabs/code/environments/production/modules/mysql/manifests/
├── backup.pp
├── bindings
│   ├── java.pp
│   ├── perl.pp
│   ├── php.pp
│   ├── python.pp
│   └── ruby.pp
├── bindings.pp
├── server
│   ├── account_security.pp
...

Notice the server.pp manifest in the top level of the mysql/manifests directory.

You were able to declare this class as mysql::server. Based on this scoped class name, Puppet knows to find the class definition in a manifest called server.pp in the manifest directory of the MySQL module.

So mysql::server corresponds to:

/etc/puppetlabs/code/environments/production/modules/mysql/manifests/server.pp

To take an example one level deeper, the mysql::server::account_security class corresponds to:

/etc/puppetlabs/code/environments/production/modules/mysql/manifests/server/account_security.pp

Account security

For security reasons, you will generally want to remove the default users and the 'test' database from a new MySQL installation. The account_security class mentioned above does just this.

Go back to your site.pp manifest and include the mysql::server::account_security class in the learning.puppetlabs.vm node. Remember, you don't need to pass any parameters to this class, so a simple include statement will work in place of a parameterized class declaration.

node 'learning.puppetlabs.vm' {
  include ::mysql::server::account_security
  ...
}

Validate your site.pp

puppet parser validate /etc/puppetlabs/code/environments/production/manifests/site.pp

When it checks out, trigger a puppet run:

puppet agent -t

You will see notices indicating that the test database and two users have been removed:

Notice:
/Stage[main]/Mysql::Server::Account_security/Mysql_database[test]/ensure:
removed
Notice:
/Stage[main]/Mysql::Server::Account_security/Mysql_user[@localhost]/ensure:
removed
Notice:
/Stage[main]/Mysql::Server::Account_security/Mysql_user[root@127.0.0.1]/ensure:
removed


Types and providers

The MySQL module includes some custom types and providers that let you manage some critical bits of MySQL as resources with the Puppet DSL just like you would with a system user or service.

A type defines the interface for a resource: the set of properties you can use to define a desired state for the resource, and the parameters that don't directly map to things on the system, but tell Puppet how to manage the resource. Both properties and parameters appear in the resource declaration syntax as attribute value pairs.

A provider is what does the heavy lifting to bring the system into line with the state defined by a resource declaration. Providers are implemented for a wide variety of supported operating systems. They are a key component of the Resource Abstraction Layer (RAL), translating the universal interface defined by the type into system-specific implementations.

The MySQL module includes custom types and providers that make mysql_user, mysql_database, and mysql_grant available as resources.

Database, user, grant:

These custom resource types make it possible to manage a new database with a few lines of puppet code.

Add the following resource declaration to your site.pp node definition. (Remember the :set paste command if you need it.)

  mysql_database { 'lvm':
      ensure  => present,
      charset => 'utf8',
  }

Similarly, with a user, all you have to do is specify the name and host as the resource title, and set the ensure attribute to present. Enter the following in your node definition as well.

  mysql_user { 'lvm_user@localhost':
    ensure => present,
  }

Once you've added declarations for these three custom resources, use the puppet parser validate command on the site.pp manifest to check your syntax

puppet parser validate /etc/puppetlabs/code/environments/production/manifests/site.pp

When your code looks good, trigger a puppet run:

puppet agent -t

less /etc/puppetlabs/code/environments/production/modules/mysql/manifests/server/providers.pp 
less /etc/puppetlabs/code/environments/production/modules/mysql/README.md
 
 
 



