grails create-app TekDays                                   # Create a new app
cd TekDays
grails run-app                                              # Run the app
grails create-domain-class com.tekdays.TekEvent             # Create a domain class
vi test/unit/com/tekdays/TekEventControllerSpec.groovy      # Edit/add unit tests
grails test-app unit: TekEvent                              # Run unit tests
grails create-controller com.tekdays.TekEvent               # Create a controller
vi grails-app/conf/BootStrap.groovy                         # Create test data
grails generate-all "*"                                     # Generate code for dynamic scaffolding

vi grails-app/views/layouts/main.gsp                        # Change look-and-feel across entire app
web-app/css/main.css                                        # CSS code for the scaffolded views
grails create-service com.tekdays.Task                      # Create a service class
grails create-integration-test com.tekdays.TaskService      # Create integration test
grails test-app integration                                 # Run all the integration tests (against 'test' database)
grails create-tag-lib com.tekdays.TekDays                   # Create a custom TabLib in grails-app/taglib/com/tekdays/TekDaysTagLib.groovy


Introducing GORM
What we just did is almost trivial as far as code goes but very interesting
behind the scenes. To set the value for the organizer property of each TekEvent ,
we are calling the method TekUser.findByFullName() . This method doesn’t actually
exist. We mentioned earlier that Grails adds methods to our domain classes
at runtime. This is not one of them. Instead, what Grails is doing here is
synthesizing behavior at runtime. When a method call beginning with findBy
is made on one of our domain classes, Grails will parse the rest of the method
name to see whether it matches any of the properties of the class. Then it
executes the behavior that we would expect if a method with that name and
parameters did exist. This is called a dynamic finder, and it is part of one of
Grails’ core components called Grails Object Relational Mapping (GORM).

As we mentioned in Metaprogramming, on page 9, Grails takes advantage of Groovy’s
metaprogramming capabilities to synthesize finders for our domain class properties
at runtime. We can call methods that begin with findBy, findAllBy, or countBy, followed
by one or more properties and optional operators.
Some examples will make this clearer. All of these would be valid methods on TekEvent :
• countByCity('New York')
• findAllByStartDateGreaterThan(new Date())
• findByCityAndDescriptionLike("Minneapolis", "%Groovy%")
Properties in dynamic finders can be joined by And or Or .


# Operators in dynamic methods:
https://grails.org/wiki/OperatorNamesInDynamicMethods

=======

void "test toString"() {
        when: "a tekEvent has a name and a city"
                def tekEvent = new TekEvent(name:'Groovy One',
                                city: 'San Francisco',
                                organizer: [fullName: 'John Doe']
                                  as TekUser)


In the above snippet from the TekEvent unit test, Groovy allows us to coerce a Map to a class or interface with the as operator.
We’re giving the Map a fullName element for clarity, but we could just as well
have used an empty Map , since we’re not referring to any of the organizer ’s
properties in our test.

======

Grails supports many-to-many relationships implicitly by having each class
include the other in its hasMany block. In this arrangement, each class will
have a collection of the other, but one side has to be declared as the owning
side. For this, Grails uses the static variable belongsTo .

=======

The inList constraint takes as its
value a list of String s. Only values matching one of the items in the list will be
allowed; any other values will cause a constraint violation when saving. But
wait, there’s more. Grails will also use this constraint to render an HTML
<select> element in the scaffolded views.

=======

onstraints are used in generating scaffolded views for a domain class as well as for
hints in generating the database schema. But the real power of constraints is the
part they play in validation. When we call save() or validate() on one of our domain class
instances, Grails will try to validate the instance against any constraints we have
assigned. If any of the constraints are not met, the save() or validate() call will fail, and
appropriate error information will be stored in the instance’s errors[a] property.
Grails provides several handy constraints that we can take advantage of, but it also
gives us the ability to define custom constraints [b], so the possibilities are endless.
Here are some of the more useful built-in constraints:
blank (true/false): Allows an empty string value.
nullable (true/false): Allows null values.
max : Specifies the maximum value.
min : Specifies the minimum value.
vsize : Takes a Groovy range to determine bounds.
maxSize : Specifies the maximum size of a String or Collection .
minSize : Specifies the minimum size of a String or Collection .
inList : Only allows values contained in the supplied list.
matches : Requires value to match a regular expression.
unique (true/false): Enforces uniqueness in the database.
url (true/false): Only accepts a valid URL.
email (true/false): Only accepts a valid email address.
creditCard (true/false): Only accepts a valid credit card number.
validator : Takes a closure for custom validation. The first parameter is the value,
and the second (optional) parameter is the instance being validated.
a.
Error details can be found via allErrors :
errors.allErrors.each{
//iterate over errors
}
b.
See http://grails.org/doc/2.3.1/ref/Constraints/validator.html .

=======

Beyond Scafolding

Grails gives us an easy way to generate the code that does what the dynamic
scaffolding has been doing for us. We won’t see any changes to the application,
but we will have the code necessary to make changes. To get started, we will
use the grails generate-all script.

The generate-all script can be called in a few different ways. If you call it with
no arguments, you will be prompted for a name. (By convention, this would
be a domain class name.) For the more argumentative types, you can call
generate-all with a name as the argument. Both of these approaches generate
a controller, four .gsp view files, and a template, which is also a .gsp file.

A third option.  Sometimes referred to as uber-generate-all, this modification to the generate-all
script. grails generate-all "*"

=====

The work done by a controller is done in an action. Actions are methods or
closure properties of the controller. (In the code that Grails generates for us,
they are methods.) Controller actions can be accessed via URLs in the pattern:
/appname/controllerBaseName/action . The first letter of the controller’s name will be
lowercased, and the word Controller will be left off.
There are four options to properly exit a controller action. We can call the
render() method, which is added to all controllers and takes the name of a view
along with a Map containing any data the view needs. We can call the redirect()
method to issue an HTTP redirect to another URL, or the respond() method
(used in the generated actions), which looks at the requested content type to
determine what to return. (These last two methods are also added to all con-
trollers; we’ll look at them more closely in the following sections.) And we can
return null, or a Map containing data, which is referred to as a model. In this
last case, Grails will attempt to render a view with the same name as the
action. It will look for this view in a directory named after the root name of
the controller; for example, returning from the index action of the TekEventController
will cause Grails to render the view /grails-app/views/tekEvent/index.gsp .

The Index Action
The index action is called when we load the TekEvent list view. It is the default
action that is called when we navigate to this controller. For example, if we
follow the link on the default home page for the TekEventController , we’ll be calling
http://localhost:8080/TekDays/tekEvent . This will call the index action.

The last line calls respond() , which will use Grails’ built-in support for content
negotiation 3 to determine the format in which to send back our data. In this
case, the data we’re returning is being supplied by a call to TekEvent . list() 4 and
is being returned to our view as HTML. The list() is being passed the params
5
Map , from which it will pull any parameters that it can use. Notice the model
argument being given to respond() : this method can, in the case of an HTML
response being rendered, take the two arguments model and view , and the index
action is passing a model with the key tekEventInstanceCount , which contains the
result of TekEvent.count() . This value will be used in the pagination built into
the list view

This brings up another powerful feature of Grails. Many methods in Grails take a Map
as a parameter. These methods will look in the Map for the elements they need and
ignore the rest. That means that in one action we can pass the params Map to several
different methods, and each will just take from it what it needs.

The Show Action

The show action takes a TekEvent instance as a parameter. When an action takes
a domain class instance as a parameter, Grails looks for an id in the request,
and then looks up the instance with that id . In the show action, respond() returns
this instance, and the action then renders the show view.

The Create Action

Here, respond() returns a newly-created TekEvent instance, assigning any values
in the params property to the corresponding properties of the instance.
The action ends by rendering the create view.

The Save Action

Like the show action, the save action takes a TekEvent instance as a parameter.
(The use of @Transactional on this action omits the readOnly element which we
saw set to true at the beginning of the class; by default, it is false .)

Adding flush:true to any persistence-related call will force Hibernate to pass the change
on to the data source. It’s not usually necessary but good to know about when you
need it.

We then call the withFormat() [a] method on the request . form is used in the case of
a form submission; in this case, when the form in the create view is submitted
and we save the resulting TekEvent instance

[a] http://docs.grails.org/2.3.1/ref/Controllers/withFormat.html

we use the <g:message> tag, [b] called
as a method, to store a “success” message in the flash Map [c]. We then call redi-
rect() , passing it our new tekEventInstance . This will send us to the show action.
(For all other content types, we respond() with the new tekEventInstance and an
HTTP status 201 — CREATED .)

[b] http://docs.grails.org/2.3.1/ref/Tags/message.html

[c] flash is often referred to as a scope. It’s more accurate to refer to it as a Map that exists
in a special scope. Values stored in flash are available for this request and one following
request, which allows us to store a message before redirecting and have that message
be available to the redirected view.

The Edit Action

The edit action doesn’t do any editing itself: that’s left up to the update action.
Instead, edit loads up the necessary data and passes it to the edit view. Except
for the name (which determines the view rendered), the edit action is identical
to the show action.

The Update Action

Like earlier actions, update tries to retrieve the TekEvent instance passed to it
as an argument. If the instance hasErrors() , we use respond() to direct back to
the edit view and display them. The update action finishes in the same way as
does the save action, differing only in the “success” message that is stored in
flash (an “updated” message rather than a “created” message) and in the HTTP
status returned after a successful save() ( 200 OK ).

The Delete Action

The delete action is available, by default, in the edit and show views. It must
be called via a DELETE method. Going back to the beginning of our TekEvent-
Controller listing, 
class TekEventController {

    static allowedMethods = [..., delete: "DELETE"]

we see the allowedMethods property. This is a Map containing
actions and the HTTP methods that can be used to call them. This prevents
a user from entering something like http://localhost:8080/TekDays/tekEvent/delete/1
and deleting our event.

The delete action starts out much like the save and update actions—attempting
to retrieve a TekEvent instance and calling notFound() if it can’t find one. If an
instance is found, we delete it and then redirect to the index action with a
“success” message (or return the status NO_CONTENT ). There is no delete view,
for obvious reasons.

The notFound Method

    protected void notFound() {
        request.withFormat {
            form {
                flash.message = message(code: 'default.not.found.message',
                  args: [message(code: 'tekEventInstance.label',
                  default: 'TekEvent'), params.id])
                redirect action: "index", method: "GET"
            }
            '*'{ render status: NOT_FOUND }
        }
    }

As we can see here, the notFound() method simply makes the same use of with-
Format() that we’ve been seeing in the generated actions. (Having this split out
into its own separate method like this means that any of our actions can
return NOT_FOUND without having to duplicate this code.) Its form stores a “not
found” message in the flash Map and redirects to the index action. For other
content types, it simply returns NOT_FOUND .
So, that’s a tour of a generated Grails controller.




Grails Views with Groovy Server Pages

Grails uses Groovy Server Pages (GSP) for its view layer. If you’ve ever worked
with JavaServer Pages, well, you have my sympathy, but GSP will seem
familiar—only easier to work with. Grails also uses SiteMesh, [10] the page
decoration framework from OpenSymphony, to assist in the page layout.
SiteMesh will merge each of our .gsp files into a file called main.gsp (located in
TekDays/grails-app/views/layouts . This is what gives a consistent look to all of our
pages, as we saw with the dynamic scaffolding. We’ll begin our tour of the
generated views with main.gsp , followed by the four views and the template
[10] http://wiki.sitemesh.org/display/sitemesh/Home
generated for the TekEvent class. Then we’ll look at a couple of the other views
that take advantage of additional Grails features.

main.gsp starts out with some conditional comments for various versions of
Microsoft’s Internet Explorer (one for each user) [11] and a couple of HTML <meta>
tags. Next is a <title> in the <head> section. This tag contains a <g:layoutTitle>
11. See http://msdn.microsoft.com/en-us/library/ms537512(VS.85).aspx .
tag, which will substitute the <title> from the view that is being merged. After
another <meta> tag it links in a style sheet and favicon [12] that will be used by
all views (it also includes a couple of special icons for Apple devices running
iOS). Then there is the <g:layoutHead> tag. This will merge in the contents of
the target view’s <head> section. The <body> section contains an application
logo, [13] a <g:layoutBody> tag, which merges in the <body> contents of the target
view, and a <div> with the CSS class footer . This last <div> contains a spinner
image and also—along with the <head> section—contains an <r:layoutResources>
tag, which tells Grails’ Resources framework [14] to include any resources that
the target view has required using the <r:require> tag.

[10] http://wiki.sitemesh.org/display/sitemesh/Home
[12] http://en.wikipedia.org/wiki/Favicon
[13] role is an HTML attribute that is used by screen readers to identify the function of a
particular element. See http://www.w3.org/TR/xhtml-role/ .
[14] See http://grails.org/doc/2.3.1/guide/theWebLayer.html#resources .

The List View

You’ll find this code in TekDays/grails-app/views/tekEvent/index.gsp.

<li><a class="home" href="${createLink(uri: '/')}"><g:message code="default.home.label"/></a></li>
<li><g:link class="create" action="create"><g:message code="default.new.label" args="[entityName]" /></g:link></li>

This code creates the button bar just below the Grails logo. We can see two
ways that Grails provides for creating links. The createLink() method takes a
relative path and creates a URL, which is assigned to the href attribute of an
anchor tag. The <g:link> tag creates an anchor tag using the values of the controller ,
action , and id attributes (if they’re provided). If a controller is not provided, the
current controller is assumed. In this case, a link to the create action of the
TekEventController will be created. The text for the links is provided by the
<g:message> tag

<g:if test="${flash.message}">
   <div class="message" role="status">${flash.message}</div>
</g:if>

This code doesn’t show up in our figure above, but it is important to take
note of. Recall that during our discussion of controllers, we often had code
that would store text in the message element of flash . This is where that text
will show up. The <g:if> tag checks for the existence of flash.message and, if
found, displays it.

See page 69 for soure code:
<g:sortableColumn property="name" title="${message(code: 'tekEvent.name.label', default: 'Name')}" />
<snip>
<g:sortableColumn property="startDate" title="${message(code: 'tekEvent.startDate.label', default: 'Start Date')}" />

In the generated views, Grails uses the <g:message> GSP tag to read text for labels,
buttons, and other elements from message bundles, which are contained in grails-
app/i18n under our TekDays application directory. Internationalization is built into
Grails; message bundles for other languages are also stored in the i18n directory, and
contain text for various messages that we will need to show the user in our app. The
use of <g:message> here ensures that if somebody were to be using our app with a
different locale, a our user interface would be presented in the correct language.
Using the message bundles for our application’s labels and other text also means
that we have a single field to edit if we want to change a particular label or message.
Many of the instances of <g:message> in the generated views (columns in the list view’s
table, for example) provide sensible default text in case of a message not being in our
i18n files.

The <g:sortableColumn> tag is what Grails uses to provide sorting on our list
view. Note that, by default, this works only with regular properties, not object
references or collections. That is why we see a <th> tag used for the organizer
property.

<g:each in="${tekEventInstanceList}" status="i" var="tekEventInstance">
   <tr class="${(i % 2) == 0 ? 'even' : 'odd'}">
      <td><g:link action="show" id="${tekEventInstance.id}">
        ${fieldValue(bean: tekEventInstance, field: "name")}</g:link></td>
      <td>${fieldValue(bean: tekEventInstance, field: "city")}</td>
      <td>${fieldValue(bean: tekEventInstance, field: "description")}</td>
      <td>${fieldValue(bean: tekEventInstance, field: "organizer")}</td>
      <td>${fieldValue(bean: tekEventInstance, field: "venue")}</td>
      <td><g:formatDate date="${tekEventInstance.startDate}" /></td>
   </tr>
</g:each>

This code is the heart of the list view. We start with the <g:each> tag, which
iterates over the list that was passed in from the controller. By convention,
this list is named tekEventInstanceList . Each item in the tekEventInstanceList is
assigned to the tekEventInstance variable, and the body of the <g:each> tag fills
in the table row with the properties of the tekEventInstance . Notice that a Groovy
expression is used to determine the CSS class of the <tr> —powerful stuff!
Inside the <td> tags, the fieldValue() method is used to render the value of each
TekEvent property. This method retrieves the value from the given field of the
given bean —in this case, the tekEventInstance —and also calls the method
encodeAsHTML() for us, because that’s almost always what we want. (We’ll learn
about encodeAsHTML() when we look at the show view.)
One property, the last in the list, isn’t using the fieldValue() method. startDate is
a Date type, so Grails renders it using the <g:formatDate> tag, which handles
the conversion from Date to String for us. [15]

<div class="pagination">
   <g:paginate total="${tekEventInstanceCount ?: 0}" />
</div>
The final portion of the index.gsp we’ll look at is another one that we can’t see
in our figure showing the list view. The <g:paginate> tag would cause pagination
buttons to show up at the bottom of the list view if we had enough events
displayed to warrant it. This tag uses the count that we passed in from the
controller’s index action.

[15] See http://grails.org/doc/2.3.1/ref/Tags/formatDate.html.

The Show View

The show view, is in TekDays/grails-app/views/tekEvent/show.gsp.

<g:if test="${tekEventInstance?.name}">
<li class="fieldcontain">
   <span id="name-label" class="property-label"><g:message
     code="tekEvent.name.label" default="Name" /></span>
     <span class="property-value" aria-labelledby="name-label">
       <g:fieldValue bean="${tekEventInstance}" field="name"/></span>
</li>
</g:if>
<g:if test="${tekEventInstance?.city}">
   <li class="fieldcontain">
      <span id="city-label" class="property-label"><g:message
         code="tekEvent.city.label" default="City" /></span>
         <span class="property-value" aria-labelledby="city-label">
            <g:fieldValue bean="${tekEventInstance}" field="city"/></span>
</li>
</g:if>

The code that displays each property is wrapped in a set of <g:if> tags that
check for a value in the property, so that we don’t display an empty list item
for the property if there’s nothing to show. Within this code we see a couple
of examples of how Grails displays text properties. Notice the CSS class
hierarchy. The <li> tag has a fieldcontain class, and the <span> tags have a prop-
erty-label or property-value class.[16]

[16] aria-labelledby is another HTML attribute used by screen readers—here it refers to the id
of the element that is a label for this <span> . See http://www.w3.org/TR/2010/WD-wai-aria-20100916/
states_and_properties#aria-labelledby .

<g:if test="${tekEventInstance?.organizer}">
<li class="fieldcontain">
   <span id="organizer-label" class="property-label"><g:message
      code="tekEvent.organizer.label" default="Organizer" /></span>
      <span class="property-value" aria-labelledby="organizer-label">
         <g:link controller="tekUser" action="show"
            id="${tekEventInstance?.organizer?.id}">
               ${tekEventInstance?.organizer?.encodeAsHTML()}</g:link></span>
</li>
</g:if>

Here we have an example of the way Grails displays a related object. The
organizer property is rendered as a link to the TekUser show view. The <g:link>
tag has its controller and action attributes set accordingly. The id is set to a Groovy
expression that reads the id property of the organizer property of the tekEventIn-
stance that we passed in from the controller. Notice the ? after the tekEventInstance
and organizer references; this is Groovy’s safe navigation operator. When this
expression is evaluated, if either of these items is null, the whole expression
evaluates to null, and no exception is thrown!
Another thing to notice here is the use of the encodeAsHTML() method. This
method is added to all String objects and prevents any HTML code from being
processed while the page is rendering. This is helpful in defending against
cross-site scripting attacks. [17]

<g:if test="${tekEventInstance?.volunteers}">
<li class="fieldcontain">
   <span id="volunteers-label" class="property-label"><g:message
      code="tekEvent.volunteers.label" default="Volunteers" /></span>

        <g:each in="${tekEventInstance.volunteers}" var="v">
         <span class="property-value" aria-labelledby="volunteers-label">
            <g:link controller="tekUser" action="show"
               id="${v.id}">${v?.encodeAsHTML()}</g:link></span>
        </g:each>
</li>
</g:if>

One-to-many relationships are rendered simply using a <g:each> tag. Here we
see the volunteers property being displayed using one property-label <span> and a
<span> with class property-value for each item in the collection.

<g:if test="${tekEventInstance?.respondents}">
<li class="fieldcontain">
   <span id="respondents-label" class="property-label"><g:message
      code="tekEvent.respondents.label" default="Respondents" /></span>

      <span class="property-value" aria-labelledby="respondents-label">
         <g:fieldValue bean="${tekEventInstance}" field="respondents"/></span>
</li>
</g:if>

Rounding out the show view, we have the respondents collection. This property
is a collection of String objects containing email addresses. This type of collec-
tion is rendered as if it were a single String field. Grails handles converting it
to a comma-separated list,
If we wanted to, we could use a <g:each> tag to show these as a list or in a table.

[17] http://en.wikipedia.org/wiki/Cross-site_scripting


The Create View

The code for this view is in TekDays/grails-app/views/tekEvent/create.gsp .

<g:hasErrors bean="${tekEventInstance}">
<ul class="errors" role="alert">
   <g:eachError bean="${tekEventInstance}" var="error">
   <li <g:if test="${error in org.springframework.validation.FieldError}">
      data-field-id="${error.field}"</g:if>><g:message error="${error}"/></li>
   </g:eachError>
</ul>
</g:hasErrors>

Here we see another type of message block.
When a domain instance fails to save, errors are stored in an errors property.
The <g:hasErrors> tag is a conditional tag that examines the domain instance
assigned to its bean attribute and renders its body if errors are found. In the
body of the tag, we find an unordered list populated by a <g:eachError> tag,
which works rather like the <g:each> to display the errors in a list at the top
of the page.

<g:form url="[resource:tekEventInstance, action:'save']" >

The <g:form> tag sets up an HTML form. This tag has controller , action , and id (or
resource ) attributes, which will result in the URL to submit the form to. It can
also take a Map — url —that contains these as elements, as we see being done
here.

<fieldset class="form">
   <g:render template="form"/>
</fieldset>

Within the <g:form> tags, we are using the <g:render> tag to (you guessed it)
render the form template, which is used by both the create and edit views for
form elements

The Edit View

The last of the scaffolded views is the edit view.

You will find the code in TekDays/grails-app/views/tekEvent/edit.gsp . Open the file and
let’s look at a line below the opening <g:form> tag:

<g:hiddenField name="version" value="${tekEventInstance?.version}" />

Here we see <g:hiddenField> being used to create an HTML <input type="hidden">
for the version of the tekEvenInstance . This is, of course, unique to the edit view,
because it submits to the update action of the TekEventController , which is dealing
with an existing TekEvent instance. That action will check version before we
update the instance to avoid conflicts with changes by another user.


The form Template
The main body of both the create and edit views is in the form template, which
is located in TekDays/grails-app/views/tekEvent/_form.gsp . Open this file, and let’s see
what new and exciting things it has in store for us:

<div class="fieldcontain ${hasErrors(bean: tekEventInstance, field: 'name', 'error')} ">
   <label for="name">
      <g:message code="tekEvent.name.label" default="Name" />
   </label>
   <g:textField name="name" value="${tekEventInstance?.name}"/>
</div>

The create and edit views use a two-column layout similar to that of the show
view. The difference is that where the show view uses an ordered list to display
our event’s properties, this template has a <div> for each property, containing
HTML input elements. <g:textField> , for example, is a GSP tag that renders an
HTML text input field with the specified name and value attributes. Notice how
the <g:hasErrors> tag is used in a Groovy expression to determine whether to
use the error CSS class. That doesn’t look like a tag, does it? 
All GSP tags can also be called as methods.

<div class="fieldcontain ${hasErrors(bean: tekEventInstance, field: 'description', 'error')} ">
   <label for="description">
      <g:message code="tekEvent.description.label" default="Description" />
   </label>
   <g:textArea name="description" cols="40" rows="5" maxlength="5000"
      value="${tekEventInstance?.description}"/>
</div>

For the description property, Grails is using <g:textArea> , a GSP tag which
(unsurprisingly enough) renders a <textarea> element.

<div class="fieldcontain ${hasErrors(bean: tekEventInstance, field: 'organizer',
   'error')} required">
   <label for="organizer">
      <g:message code="tekEvent.organizer.label" default="Organizer" />
      <span class="required-indicator">*</span>
   </label>
   <g:select id="organizer" name="organizer.id" from="${com.tekdays.TekUser.list()}"
      optionKey="id" required="" value="${tekEventInstance?.organizer?.id}"
      class="many-to-one"/>
</div>

For properties that are references to another domain class, Grails uses a
<g:select> tag, which will render a <select> element loaded with all the available

choices for that class. In this case, we end up with a list of TekUser instances
that can be assigned to the organizer property.

<div class="fieldcontain ${hasErrors(bean: tekEventInstance, field: 'startDate',
   'error')} required">
      <label for="startDate">
         <g:message code="tekEvent.startDate.label" default="Start Date" />
         <span class="required-indicator">*</span>
      </label>
      <g:datePicker name="startDate" precision="day"
         value="${tekEventInstance?.startDate}" />
</div>

The <g:datePicker> tag renders that series of select elements

Grails is using the tag’s precision attribute
to indicate that we only want to specify a particular day (by default, the tag
will render select elements for all of year, month, day, hour, and minute).
Another useful attribute of this tag (not used here) is noSelection. [18]

<div class="fieldcontain ${hasErrors(bean: tekEventInstance, field:
   'volunteers', 'error')} ">
   <label for="volunteers">
      <g:message code="tekEvent.volunteers.label" default="Volunteers" />
   </label>
   <g:select name="volunteers" from="${com.tekdays.TekUser.list()}"
      multiple="multiple" optionKey="id" size="5"
      value="${tekEventInstance?.volunteers*.id}" class="many-to-many"/>
   </div>

Grails also uses a <g:select> tag for unidirectional one-to-many relationships.
In this case, the multiple attribute is set, and the value attribute is set to the id
of each TekUser instance in the volunteers collection property, using Groovy’s
spread operator. 19 This will render a multiselect listbox loaded with TekUser
instances. When submitted, all the selected instances will be automagically
added to the volunteers property.

<div class="fieldcontain ${hasErrors(bean: tekEventInstance, field: 'sponsorships',
   'error')} ">
   <label for="sponsorships">
      <g:message code="tekEvent.sponsorships.label" default="Sponsorships" />
   </label>
<ul class="one-to-many">
   <g:each in="${tekEventInstance?.sponsorships?}" var="s">
   <li><g:link controller="sponsorship" action="show"
      id="${s.id}">${s?.encodeAsHTML()}</g:link></li>
   </g:each>
   <li class="add">
   <g:link controller="sponsorship" action="create" params="['tekEvent.id':
      tekEventInstance?.id]">${message(code: 'default.add.label',
      args: [message(code: 'sponsorship.label', default: 'Sponsorship')])}</g:link>
   </li>
</ul>
</div>

In this block, we can see how the sponsorship collection property is rendered as
an unordered list of links. A <g:each> tag creates a <li> for each sponsorship,
and after it is closed, we have one last <li> , containing a <g:link> tag that will
render a link to the create action of the SponsorshipController . The value in the
params attribute will cause this TekEvent instance to be assigned to the tekEvent
property of the newly-created Sponsorship .
And this concludes our tour of the code behind the scaffolded views. Now
that this code is available to us and we have a working understanding of what
it is doing, we can see how we could make a few changes to make our appli-
cation a little better looking and easier to use. We’ll do that beginning in the
next chapter, but first, let’s see how we can hook up to a real database so we
no longer lose our data changes every time we restart the application.


Configuring a Database

[See page 79 of "Grails2: A Quick-Start Guide" for steps to configure a non-memory database.]


[18] See http://grails.org/doc/2.3.1/ref/Tags/datePicker.html .
[19] See http://mrhaki.blogspot.com/2009/08/groovy-goodness-spread-dot-operator.html .

Chapter 6

Change look-and-feel across whole app:
vi grails-app/views/layouts/main.gsp

Edit the above to change things like the logo image in the header included in all pages.
Change the <a href= ... > to point to the main index page for the app.
Use main.gsp to add sidebars, a foorter, a standard menu. etc.

Grails puts the CSS code for the scaffolded views in web-app/css/main.css.

The List View
We’ll start by removing the organizer from the list view. When we generated
the scaffolded views, Grails simply used the first six properties of our TekEvent
for the table in the list view. Edit the view in grails-app/views/tekEvent/index.gsp to add remove fields as desired.

The Show View

Edit the show view in grails-app/views/tekEvent/show.gsp as needed. For instance, change the default behavior/content of any date fields 
or to change how one-to-many fields are dislayed or how fields that do not have a toString() method are displayed.

<span class="property-value" aria-labelledby="startDate-label">
   <g:formatDate format="MMMM dd, yyyy"
      date="${tekEventInstance?.startDate}" /></span>

Add the 'format' [1] attribute to the <g:formatDate> tag to change the date output format.

[1]  See http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html .



The Create and Edit Views

The create and edit views share the form elements contained in the _form.gsp template.  

Note: The <g:datePicker> tag can take a years attribute, which will allow us to limit the
years from which a user can pick. (Without this attribute, the tag will just
list every year for 100 years before and after the current year.) This attribute
can take either a Range [2] or a List.

[2]  See http://groovy.codehaus.org/Collections .



Grails Service Classes

We’re going to write a method that will create several Task instances and add
them to the tasks property of a newly created TekEvent . We will define this method
in a service class. A Grails service class is a Plain Old Groovy Object (POGO)
located in the grails-app/services directory and with a name ending in Service. By
following these conventions, this plain old Groovy object will be endowed with
magical powers.

Service classes [4] are a great way to keep extra code out of our controllers. When
we have application logic that doesn’t fit well in any domain class—for
example, logic that involves multiple domain classes—it is tempting to add
this code to the controller. Doing this can lead to bloated controllers that are
difficult to read and maintain. To keep our controller leaner, we can move
this type of application logic into service methods.

[4]  You can find more details on Grails service classes at http://grails.org/doc/2.3.1/guide/ser-
vices.html.

Script to create Grails service classes: 

grails create-service com.tekdays.Task

package com.tekdays

import grails.transaction.Transactional
class TaskService {
   def serviceMethod() {
   }
}

We start with a stubbed-out method called serviceMethod() , which by default
will be executed in a transaction. [5] This is because, by default, any method
declared in a service class in Grails will be executed within a transaction. [6]
We don’t have to do anything to enable transactions; everything is handled
behind the scenes by Spring and Hibernate.

Add new service methods as needed.

[5]  See http://en.wikipedia.org/wiki/Database_transaction.
[6] If you’re creating a read-only service, or one that doesn’t use the database at all, you
can disable this by setting the transactional property to false . See http://grails.org/doc/2.3.1/guide/
services.html#declarativeTransactions.

To use a service class from within a controller class just declare a property at the top of the class named after the service class 
(with the first letter lowercase), and an instance of that class will be injected into the controller at runtime. That's
autowiring Grails style. e.g.

class TekEventController {
➤
   def taskService

Then reference the property in controller actions. e.g.

def save(TekEvent tekEventInstance) {
<snip>

   taskService.addDefaultTasks(tekEventInstance)
<snip>
}


Integration Testing

We create an integration test by running the Grails script create-integration-test .
An integration test is a Spock specification or JUnit test case, just like a Grails
unit test. The difference is in what is available to the test at runtime. Unit
tests are meant to test a unit (class) in isolation, so Grails doesn’t give unit
tests any of its dynamic goodness. Integration tests are meant to test multiple
classes working together. When running integration tests, Grails adds all of
the dynamic behavior that we’re taking advantage of in our application.
Since the process of adding default tasks to an event involves the TaskService ,
Task , and TekEvent classes, an integration test is a good fit. Run the create-integra-
tion-test script:
$ grails create-integration-test com.tekdays.TaskService


Integration class files are found under test/integration/...

Note: Integration tests will use the data source for the test environment. Before running
integration tests, you may want to set the data source for this environment to a per-
sistent database.

The last section of the chapter shows an example of how to handle the content/display of boolean fields.


Chapter 7 Forum Messages and UI Tricks

This chapter provides a running example for creating/displaying threaded messages for an event and demonstrates how to create custom views, GSP taglibs and AJAX calls.

The <g:link> tag will create a link to the index action of the TekMessageController
and will pass a TekEvent.id.

The TekMessageConotroller index() method is updated to handle messages for a single TekEvent if a TekEvent ID is passed in otherwise the default behavior is used.

Next the "new TekMessage" view is updated to allow a TekEvent ID to be passed in so that the TekMessage view does not have to prompt for this information.

All we did here was add a params attribute to the <g:link> tag. This attribute is
a Map containing parameters to be added to the URL created by the <g:link>
tag. We then assign event.id to a key of the same name. (Since the key contains
a “.”, we had to put it in quotes.) This will result in a parameter like event.id=2 .
Grails’ binding will use that to retrieve a TekEvent instance and assign it to the
TekMessage.event property. All of that and more is done with the following single
line:
respond new TekMessage(params)

Believe this allows the view to respond with just the content for a single TekMessage.

The book now shows how to create a custom AJAX enabled view (ajaxIndex.gsp) that displays the threaded messages for a single event with a "detail" pane to show the details for a single message. AJAX is used to update the view to retrieve and display the details for a single message. The TekMessage list and show views are replaced with the ajaxIndex.gsp view.

GSP templates are simply chunks of GSP code in a file that begins with an
underscore ( _likethis.gsp ). They provide an easy way to share common code
across multiple pages (Grails’ use of the _form.gsp template for our create and
edit views is a great example of this). You can include a template in a GSP
page with the <g:render> tag, like this:
<g:render template="someTemplate" />
This line would render a template called _someTemplate.gsp in the same directory
as the page that it is being called from. To render templates from a different
directory, we add the path before the name of the template. We never include
the “_” at the beginning of the template name in the <g:render> tag.
Another popular use for GSP templates is rendering the response to Ajax
calls; that’s what we’re after here. Before we get too much further, let us lay
out the plan.


Creating the Template
Now we need to create the template that will display an individual message.
This time, just create a blank file called _details.gsp in the TekDays/grails-
app/views/tekMessage directory. We’ll borrow the <div> , <ol> , and three <li> tags
from TekDays/grails-app/views/tekMessage/show.gsp . (The three <li> tags are for the
subject , content , and author properties.) Because this file’s code will be inserted
into another page, it doesn’t need its own <html> or <head> tags.

Looking at the code for our template, we can see that the only data element
that it will need is a TekMessage instance called (believe it or not) tekMessageIn-
stance . This is important to note, because when a template is rendered, the
data it requires needs to be passed to it. A template cannot automatically see
the data elements of the page that renders it.

Looking at the code for our template, we can see that the only data element
that it will need is a TekMessage instance called (believe it or not) tekMessageIn-
stance . This is important to note, because when a template is rendered, the
data it requires needs to be passed to it. A template cannot automatically see
the data elements of the page that renders it.

Now we can use one of Grails’ Ajax tags, and it will adapt to use the jQuery
library. [2] The tag we’re going to use is <g:remoteLink> .

The <g:remoteLink> tag can take controller , action , and id attributes. If the controller
attribute is not provided, then the controller that rendered the current page
will be used by default. Since the ajaxIndex view will be rendered by the
TekMessageController , we don’t need to specify it here. We did give it an action
attribute, which points to an action (which we will create next in the TekMes-
sageController ). Then for the id , we use the tekMessageInstance variable from the
<g:each> . The final attribute that we set on the <g:remoteLink> tag is update . This
attribute contains the ID of the HTML element on this page that will be
updated with the result of the action—in this case, details .

[1] See the Grails website for a list of supported libraries: http://grails.org/doc/2.3.1/guide/theWe-
bLayer.html#ajax .
[2] Grails handles any differences that might exist in the way different JavaScript libraries
handle the tasks involved in the Ajax tags; the behavior of these tags is the same
regardless of which of the supported libraries we use.

For the body of the <g:remoteLink> , we used the tekMessageInstance variable to
build a string containing the name of the message’s author and the subject
of the message.

``iOpen TekDays/grails-app/controllers/com/tekdays/TekMessageCon-
troller.groovy , and add the following action:
forum.2/TekDays/grails-app/controllers/com/tekdays/TekMessageController.groovy
def showDetail() {
   def tekMessageInstance = TekMessage.get(params.id)
   if (tekMessageInstance) {
      render(template:"details", model:[tekMessageInstance:tekMessageInstance])
   }
   else {
      render "No message found with id: ${params.id}"
   }
}

This action expects the params to contain an id value. The first thing we do is
define a tekMessageInstance variable and retrieve a TekMessage using the id value
in the params . If we have a valid instance, we call the render() method and pass
it the name of a template (“details”) and a model , which is a Map . The model
parameter is used to provide the data that the template will need; in this case,
we have only one object in the model, but we can include as many objects as
our template needs. The render() method will merge our template with the data
in the tekMessageInstance bean and return the results as HTML. This HTML will
then replace the contents of the <div> on our page.

Now there’s just one thing left to do before we can marvel at our handiwork:
we need to provide a way to reach our new view. If we added an action to the
TekMessageController called ajaxIndex , it would automatically render our new view,
but it would just be a copy of the index action, and that wouldn’t be very DRY.
So, we’ll use a different approach. The same render() method that we just used
for our details template can be used to render an entire view.

This time, we pass a view parameter instead of a template . We set that parameter
to our new page, and then we pass the existing Map as the model . Now when
the index action is called (for example, when we navigate to http://localhost:8080/
TekDays/tekMessage/index ), our new view will be rendered.

The end of the chapter shows how to create a TagLib containing a resuable library call. In this case to create an indented threaded message content.


Chapter 8: Knock, Knock: Who's There? Grails Security

This chapter walks through using Grails filters to create a simple user authentication mechanism. If users attempt to access a privileged part of the application they are redirected to the login page. After successfully authenticating the user is redirected back to the privileged part of the app.

The grails-app-views/tekUser/login.gsp view is created containing an HTML form to capture the user's username and password. The Form action redirects to the "validate" action to validate the username and password.

After a standard Grails message block (which we will need if
there are problems during login), we have an HTML form with fields for username
and password , followed by a submit button. This page will be merged with our
standard header because of this line: <meta name="layout" content="main" /> .

One important point about this code is the action that we’ve assigned to the
<g:form> : validate . This action will be called when we submit the form. It will
reside in the TekUserController and will use the form data to load an existing
TekUser if found.

Next the validate() action is created in the grails-app/con-
trollers/com/tekdays/TekUserController.groovy controller.

The validate() action attempts to retrieve a TekUser for the params.username set by the HTML form. If found then the params.password is compared to the password for the retrieved TekUser. If everything is successful the TekUser object is added to the session scope via the session.user key and the user is redirected (for now to the TekEvent index() action...but shortly to the expected controller and actions). If the user fails to be authenticated then a flash.message is set and the login view is rendered which will display an error message.

This action, rather than the login action, does the real work of logging a user
into the system. In the first line, we define the variable user , to which we assign
the result of a call to TekUser.findByUserName(params.username) . Next we check to
see whether our user has a value and, if so, whether its password matches
params.password . If both of those things are true, then we’ll stuff this TekUser
instance in the session for later use and call the redirect() method to send the
user to the index action of the TekEvent controller. If either is false, we add a
message to flash and call the render() method to redisplay the login view.
You’ll notice that we used two methods that we didn’t define anywhere. The
redirect() and render() are added to all controller classes at runtime by Grails.
The redirect() method will perform an HTTP redirect. That is, it will return a
response to the client that will cause it to make a subsequent call to the URL
that is created by the controller and action parameters.
The render() method is very versatile. We used it earlier to respond to an Ajax call.
In that instance, we passed it a template; here we pass it a view. In both cases,
the end result was to send a chunk of text back to the client. This method can
also be used to render XML, JSON, or any arbitrary text to the client.
In this action, we write to session , which is a Map stored in the Session scope.
Anything we put there will be available as long as this user is interacting with
our application. And since it is a Groovy Map , we can add new key/value pairs
by assigning a value to a nonexistent key. There was no user key in session , but
we added the key and assigned the value in the following line: session.user =
user . We did the same with flash , which is a Map stored in a special scope that
lasts for this request and the next, after which the values we put in will be
cleared out.
Now that we have a login page and a process for logging a user in, let’s see
how we can use filters to prompt the user to log in at the appropriate times.
Filters
Filters allow us to hook into, or intercept, the processing of a request. There
are interceptors for before , after , and afterView . There are many uses for filters,
and you can have as many filters as you need in an application. In our case,
we’ll use a filter to determine whether a user is logged in when they try to
access a “secure” page.

Grails makes implementing filters a snap. Create a Groovy class
with a name ending in Filters, and place it in the grails-app/conf directory. In
this class, define a code block called filters , and then include individual filters
as if they were methods. Each filter (method) can take named parameters for
controller and action . Calls to this controller and action pair will be intercepted
by this filter. (An asterisk can be used as a wildcard to represent any controller
or action.) But enough chatter—let’s get to the code.
Create a new file called TekDays/grails-app/conf/SecurityFilters.groovy

lass SecurityFilters {
    def filters = {
        doLogin(controller:'*', action:'*'){
            before = {
                if (!controllerName)
                    return true
                def allowedActions = ['show', 'index', 'login',
                                      'validate']
                if (!session.user && !allowedActions.contains(actionName)){
                    redirect(controller:'tekUser', action:'login',
                             params:['cName': controllerName,
                                     'aName':actionName])
                    return false
                }
            }
        }
    }
}

In our SecurityFilters class, we create a single filter called doLogin with a before
interceptor. We use wildcards for both controller and action parameters, which
means this filter will be called for all actions. We don’t actually want to require
the user to log in for every action, so we will fine-tune this filter further.
Every filter has certain properties injected into it by Grails; among these are
controllerName and actionName . These represent the original controller and action
that the user was trying to access before the filter so rudely interrupted. We
will use the actionName to determine whether we really want to filter this call.
We’ll do this in two steps. In the first step, we’ll check to see whether we have
a controllerName . If we don’t, then we can assume the user is going to the default
home page ( index.gsp ), in which case we will return true . For the second step,
we define a List variable with the names of actions that we want to allow. Along
with the innocuous actions show and index , we included the login and validate
actions to avoid unintended login loops. Then in our if comparison, we check
to see whether this list contains the current actionName .
The other thing we check in the if comparison is whether we already have a
user in the session . If we do not have a user and the current action is not in the
allowedActions list, we redirect to the login action of the TekUserController and pass
along the controllerName and actionName values in the params parameter. (We’ll
need them shortly.) In the final line, we return false , which will prevent any
other filters (or the original action) from being called.

The above filter redirects to the TekUserController login() action if the user needs to be authenticated. It adds to params a map containing the controller and action the user attempted to access.

The TekUserController login() action is updated next to check for the existence of the controller/action name pair:

    def login() {
        if (params.cName)
            return [cName:params.cName, aName:params.aName]
    }

This code checks to see whether those two values are available in params and,
if so, passes them on to the view in the returned Map . Next, we’ll modify the
view to pass these values on to the validate action. Open TekDays/grails-
app/views/tekUser/login.gsp , and add the following hidden input elements somewhere
inside the <g:form> .

<input type="hidden" name="cName" value="${cName}">
<input type="hidden" name="aName" value="${aName}">

Now when the form is submitted, the controllerName and actionName values from
the filter will be passed on to the validate action. We will now use these values
to redirect the user to their original destination on successful login.
Open TekDays/grails-app/controllers/com/tekdays/TekUserController.groovy ,

The TekUserController validate() action is updated to check for the existence of the controller name, via params.cName, and if found redirects to the specified controller and action, otherwise it is assumed the user wants to redirect to the default index() action.

Finally, the TekUserController logout() action is created to logout the user by setting the session.user key to null and redirecting to the default '/' URL.

Since the way that our filter determines whether a user is logged in is by the
existence of a value in the user key, we set that key to null to “log them out.”
We don’t need to check for a user key before we do this; if it doesn’t exist, it
will be created and set to null . Then, to send the logged-out user back to the
home page, we use the redirect() method. In most cases, this method will take
an action , or a controller and action pair. But it can also take a url , or, as in this
case, a uri . Simply redirecting to a URI of / will return us to the home page no
matter where we are in the application.

A taglib named loginToggle is created to embed text in the main layout. The content indicates whether the user is logged in or out and updates a link to the appropriate TekUserController login() or logout() action to either log the user in or out.

This tag doesn’t need any attributes or a body, so we skip the closure
parameters altogether. We start by writing out an opening <div> . Then we
check to see whether a user exists. If we have a user, we output a “Welcome”
message and a link to allow them to log out. For the message, we use
${session.user} inside a GString . (This will lead to a call to the TekUser.toString()
method, which we defined earlier.) For the link, we use a regular anchor tag
along with the <createLink> tag, called as a method. If there is no user, we just
output a link to allow the user to log in. There’s also a little CSS, but that’s
not too exciting.
We’ll use this new tag in TekDays/grails-app/views/layouts/main.gsp


 Chapter 9: Big-Picture Views

In this iteration, we’re going to implement an organizer’s dashboard view. This view will not
be tied to any one domain class but will interact with most (if not all) of them
at one time. We might even hit data that is not from our domain.

The chapter starts by refactoring the default homepage view in grails-
app/views/index.gsp. 

Take a look at the default content that is generated. It contains logic to get lots of interesting information about the grails app including grails version, groovy version, JVM version, and details about available controllers, domain classes, services, and tag libraries.

 
The chapter moves on to create a Dashboard view for a TekEvent which pulls together information for various domain classes.

Sidebar:
The Grails convention of naming a controller with a domain class name followed by
Controller, and the way that the generate-all script takes a domain class and generates
a conventionally named controller and standard views in a directory with the same
name, can make it seem like everything must be based on a domain class. The fact
is that aside from the work of generate-all , there is no link between a domain class and
a controller.
Any domain class can be accessed from any controller. The static methods that Grails
adds to domain classes ( get() , list() , and so on) are available in any controller.
The real convention-based link is between controllers and views. An action in a con-
troller will, unless directed otherwise, attempt to render a view named after the action,
in a directory named after the controller. For example, a bar action in FooController will
attempt to render the view in ../grails-app/views/foo/bar.gsp .

A new Dashboard controller is created using grails create-controller com.tekdays.Dashboard.

A barebones Dashboard view in grails-app/views/dashboard/dashboard.gsp is created. The barebones content is:
<html>
  <head>
   <title>TekDays - Dashboard</title>
   <meta name="layout" content="main" />
  </head>
  <body>
   </body>
</html>
 
This page will have a good amount of content in it, so in order to keep it
manageable from a coding standpoint, we’ll compose the page out of a series
of templates. Our main dashboard page will consist of several <g:render> tags,
which can easily be rearranged and styled as necessary.

We added several <div> tags containing <g:render> tags. We can tweak the
styling on these elements or change their order or what have you. Now we
can address each template on its own, which will help our discussion (as well
as our code) to be more organized. Recall that the <g:render> tag will insert the
final HTML of the designated template inside the containing element—in this
case, the <div> .

The template for rendering "Sponsors" is interesting in that Many-to-Many relationships must be handled.

A dashboard() action is created ingrails-app/controllers/com/tekdays/Dash-
boardController.groovy. It is this action that builds a map of all the related domain objects for a TekEvent. When the dashboard() action returns the dashboard view is invoked to render content. The map provided by the dashboard() action is used to display content in the view.

A simple menu is added to the dashboard view.

Finally, a menu link is added from the TekEvent show view to allow navigation to the dashboard view for the TekEVent.



Chapter 10: Seek, and You Shall Find

This chapter covers various search alternatives.
1. Dynamic Finders
2. Hibername Criteria Builder
3. The Searchable Plugin

The first example uses Dynamic Finders.

Dynamic Finders take the form:
<domain class>.findAllBy<property type>(<property instance)

Dynamic finders are great, and as you work with Grails, you will find yourself
using them again and again, but they can take you only so far. For one thing,
they are limited to top-level properties of the class—you cannot use dynamic
finders to search relationships.

Hibername Criteria Builder
Our next search feature is to find TekEvent instances for which a logged-in user
has volunteered. Volunteers for an event are in the volunteers collection, which
is the result of a one-to-many relationship between TekEvent and TekUser . To
search relationships, we must turn to a different tool in the Grails toolbox.
The Criteria Builder in Grails is a very powerful and flexible tool for retrieving
objects. It is based on the Hibernate Criteria API, so you can dig deeper by
studying that technology. [1] However, this is Grails we’re talking about, so you
can do plenty with this tool by following some simple examples.
All Grails domain classes have a static createCriteria() method that returns a
HibernateCriteriaBuilder instance. This builder has a list() method that takes a clo-
sure. Inside this closure, we can define the criteria for our search.
Here’s an example:
def g3Events = TekEvent.createCriteria().list{
  and{
  gt('startDate', new Date())
  or{
    ilike('description', '%groovy%')
    ilike('description', '%grails%')
    ilike('description', '%griffon%')
    }
  }
}

Another nice feature of Criteria Builders is that relationship properties can
easily be searched. This is also done with nested criteria blocks. Let’s see how
this looks:
[1] http://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/querycriteria.html

def contegixEvents = TekEvent.createCriteria().list{
  sponsorships{
    sponsor{
      eq('name', 'Contegix')
    }
  }
}



The Searchable Plugin

What we’ll do instead
is provide a single search field on our home page, and we’ll search for all
possible matches to the value entered in that field. To do this, we’ll take
advantage of one of the most powerful plugins in the Grails ecosystem; the
Searchable plugin [2] takes the indexing and search capabilities of Compass
and Lucene and makes them easy to use. It makes them so easy, in fact, that
we call it “Grails-easy.”

[2] Developed by Maurice Nicholson; see http://grails.org/plugin/searchable .

To install a plugin,
we simply declare it as a dependency in BuildConfig.groovy . (We can get the
dependency that we need to declare from the plugin’s page in the plugin
portal; the dependency for the Searchable plugin, for example, is listed at
http://grails.org/plugin/searchable .)

e.g.
plugins {
// plugins for the build system only
build ":tomcat:7.0.42"
// plugins for the compile step
compile ":scaffolding:2.0.1"
compile ':cache:1.1.1'
compile ":webxml:1.4.1"
compile ":searchable:0.6.6"
<snip>

}


Sidebar: The 'searchable' plugin requires compass-2.2.1 which was not available in the default list of repositories. I had to add 
         the 'mavenRepo "http://repo.grails.org/grails/core"' line to the
         repositories configuration in conf/BuildConfig.groovy. See below: 
  repositories {
        inherits true // Whether to inherit repository definitions from plugins

        grailsPlugins()
        grailsHome()
        mavenLocal()
        grailsCentral()
        mavenCentral()
        // uncomment these (or add new ones) to enable remote dependency resolution from public Maven repositories
        //mavenRepo "http://repository.codehaus.org"
        //mavenRepo "http://download.java.net/maven/2/"
        //mavenRepo "http://repository.jboss.com/maven2/"
        mavenRepo "http://repo.grails.org/grails/core"

  I also had to stop the app, run the 'grails refresh-dependencies' command, and then restart the app.

=======end sidebar======

For any domain class that you want to be searchable add the line
static searchable = true

That single line of code, static searchable = true , enables full-text search
of all the simple properties of the TekEvent. A method named search() will be added by the Searchable plugin. It takes a 
search phrase as input.he search() method returns a
SearchResult instance, which contains a results property that is a List .

Sidebar:
At times, you may need to search for objects based on the properties of related objects.
The Searchable plugin makes this easy also. Let’s say, for example, that you want to
be able to search for TekEvent instances based on the properties of their organizer or
volunteers . These are both of type TekUser , so add this line to the TekUser class:
static searchable = true
Now go to the TekEvent class, and change that searchable declaration to look like this:
static searchable = {
  organizer component: true
  volunteers component: true
}

All you did was turn TekUser into a searchable class. Then you used the Searchable
plugin’s mapping DSL to tell it that the organizer and volunteers properties are searchable
components. Notice that you don’t have searchable = true anywhere in the TekEvent class;
assigning a mapping closure to the searchable property automatically sets it to true.
There’s a great deal more that can be done with the Searchable plugin—much more
than we can cover here. Fortunately, you can find extensive documentation at
http://grails.org/plugin/searchable .

A search() action is added to the TekEventController.groovy controller that will invoke the TekEvent.search() Searchable method to perform the search when needed.

Finally the following logic is added to the grails-app/views/index.gsp to add a form to allow the user to search:
<div id="homeSearch">
  <g:form controller="tekEvent" action="search">
    <label>Search:</label>
    <input id="query" type="text" name="query" />
    <input type=submit value="Go" />
    </g:form>
</div>


The above form will invoke the TekEventController.search() method when the form is submitted.

One last tweak is needed. The grails-app/conf/SecurityFilters.groovy class is updated to allow the search action to be invoked without the user being logged into the application.


Chapter 11 Icing on the Cake

The jQuery UI Plugin
The first item on the new list is really just an improvement on one of the
original features. We did provide a way for people to volunteer to help on
events, but it’s not very user friendly. So, we’ll tackle this one right away.
We’ll add a button to the TekEvent show view that will allow logged-in users to
volunteer to help on this event. When they click it, we’ll show them a nice
confirmation dialog box, and if they confirm, we’ll add them to the volunteers
collection for that event.
We’ll start with the button. At first, that would seem as simple as adding a
<button> tag somewhere on our page. But there is some logic involved. We
don’t want to show the button if the user is not logged in. Then if they are
logged in, we don’t want to show the button if they are already volunteering
for this event.
We will put this logic into a custom tag.

The following taglib is added to grails-app/taglib/com/tekdays/TekDaysTabLib.groovy:
    def volunteerButton = {attrs ->
        if (request.getSession(false) && session.user){
            def user = session.user.merge()
            def event = TekEvent.get(attrs.eventId)
            if (event && !event.volunteers.contains(user)){
                out << "<span id='volunteerSpan' class='menuButton'>"
                out << "<button id='volunteerButton' type='button'>"
                out << "Volunteer For This Event"
                out << "</button>"
                out << "</span>"
            }
        }
    }


If a user is logged in, there will be a TekUser in the session called user , so that’s
our first test. If we have a logged-in user, we’ll call the merge() method on it.
(We need to do this because objects stored in the session become detached
from the Hibernate session.) Then we use the eventId attribute to get the TekEvent
instance. Once the user has been merged, we can pass it to the contains() method
of the event.volunteers to see whether this user is already a volunteer. If they
are not, we’ll go ahead and write out the button.

We start with a <span> with
a class of menuButton and id of volunteerSpan . Note this id ; it will become important
shortly.
Next we write out the <button> with its id and type , followed by the text of the
button. We finish by closing up all our tags.
Now we’ll drop this tag in the navigation bar on the TekEvent show view, in
TekDays/grails-app/views/tekEvent/show.gsp .

<li><g:volunteerButton eventId="${tekEventInstance.id}" /></li>

The next thing is to make the button do something and add a confirmation dialog.

What we
want is a confirmation dialog box, followed by a call to an action that will add
this user to the volunteers collection of this TekEvent . Since we don’t want a
boring JavaScript dialog box, we’ll use the jQuery UI plugin to get a much
more attractive one.
The jQuery UI plugin [1] includes jQuery UI [2] resources (CSS and JavaScript) in
our GSP pages, making it simpler to work with the library in a Grails applica-
tion. Some of the components included in jQuery UI are Autocomplete, Tabs,
Progressbar, and the one we’re going to use, Dialog. To install the plugin, add
the following dependency to the list of compile step plugins in TekDays/grails-
app/conf/BuildConfig.groovy :
compile ":jquery-ui:1.8.24"

[1] http://grails.org/plugin/jquery-ui
[2] You can find very detailed documentation on jQuery UI at http://jqueryui.com/ .


 
Add the dialog box component to our TekEvent show view.
Back in TekDays/grails-app/views/tekEvent/show.gsp , go ahead and add the highlighted
lines to the <head> section:

  <g:javascript library="jquery" />
  <r:require module="jquery-ui" />

Just as we saw in Ajax in Grails, on page 112, the <g:javascript> tag here is
declaring the JavaScript library that we’re using. (The jQuery UI plugin
depends on the jQuery plugin, [3] which is included in our app automatically
by Grails.) The <r:require> tag is being used to tell Grails’ Resources framework
that we are using the jquery-ui module provided by the jQuery UI plugin.
Next, we need to add the code for the jQuery UI dialog component. Add the
following code right before the closing </body> tag:

    <script type="text/javascript">
        $(document).ready(function() {
            $('#volunteerDialog').hide();
            $( "#volunteerButton" ).click(function() {
                $("#volunteerDialog").dialog({
                    resizable: false,
                    height:180,
                    width: 420,
                    modal: false,
                    buttons: {
                        "Submit": function() {
                            $.ajax({
                                type: "post",
                                dataType: "html",
                                url: "${g.createLink(action:'volunteer')}",
                                async: false,
                                data: $("#volunteerForm").serialize(),
                                success: function (response, status, xml) {
                                    $("#volunteerSpan").html(response);
                                }
                            });
							
                            $(this).dialog("close");
                        },
                        Cancel: function() {
                            $(this).dialog( "close" );
                        }
                    }
                });
            });
        });
    </script>
    <div id="volunteerDialog" title="Volunteer for ${tekEventInstance.name}">
      <g:form name="volunteerForm" action="volunteer">
        <g:hiddenField name="id" value="${tekEventInstance.id}" />
        <p>Welcome to the team! Your help will make a huge difference.</p>
      </g:form>
    </div>

[3] http://grails.org/plugin/jquery


Note how easy Grails makes it for us to add JavaScript to a GSP. Our new
JavaScript code here is using jQuery UI to show and hide a simple volunteerDialog
<div> , which contains a <g:form> with a hidden input for the id of our event.
The form’s action attribute is set to volunteer , which is the name of the TekEvent-
Controller action that we will use to add the logged-in user to this event’s
volunteers.
OK. Our dialog box is all set up. We could even run this now and it would
show up, but we would just get a nasty error in the console if we tried to
submit. Let’s create the volunteer action in TekDays/grails-app/controllers/com/tek-
days/TekEventController.groovy , like so:

    def volunteer = {
        def event = TekEvent.get(params.id)
        event.addToVolunteers(session.user)
        event.save()
        render "Thank you for Volunteering"
    }

The volunteer action is the heart of this feature, even though it’s only a few
lines of code. First we use the id that was passed in the hidden input field to
get the TekEvent instance. Then we add the logged-in user ( session.user ) to the
volunteers collection. Next, we save the event, and finally, we render a text
message that will replace the button in the volunteerSpan . This action is a great
example of how the productivity of Grails doesn’t come in scaffolding or code
generation; it comes in the way you are able to accomplish so much with so
little code. Scaffolding helps out as you start a new application, but this
ability to enhance and expand your application quickly is where the real
productivity gains come in.

See the chapter for a walkthru regarding how to use the twitter4J API.

User-Friendly URLs
We now need to provide a way to access our event page using a simple URL.

Grails provides a simple way to do this. Every
Grails application has a UrlMappings class, which uses a DSL [7] to build URL
mappings. The conventional Grails mappings are in there by default, and we
can add as many different mappings as needed. Let’s take a look at the default

7.  Domain-specific language.

mappings to get an idea of how this works. Open TekDays/grails-app/conf/UrlMap-
pings.groovy :

class UrlMappings {
  static mappings = {
    "/$controller/$action?/$id?(.${format})?"{
      constraints {
         // apply constraints here
      }
    }
    "/"(view:"/index")
    "500"(view:'/error')
  }
}

The static mappings block is the heart of the UrlMappings class. Inside this block
we see the mappings for the conventional Grails behavior. The first value
found after the root ( / ) will be assigned to the controller variable. The next value
will be assigned to the action , and the one after that will be assigned to the id .
(In the case of using file extensions for content negotiation, a file extension—
which would then be the last value—would be assigned to the format variable.)
The first variable, controller , is required; the rest have a ? on the end, which
marks them as optional. What this means is that any URL with one, two,
three, or four values after the root (including a file extension) will match this
mapping and be applied accordingly. If we were to create a FooController , /foo
would be mapped to the FooController ’s default action, /foo/bar would be mapped
to the bar action of FooController , and /foo/bar/baz would be mapped to the bar action
of FooController with an id parameter of baz .

Inside the mapping block there is an empty constraints block, where we can put
constraints on the different variables, much as we did earlier on domain class
properties. After this, we have the two other default mappings. The root
mapping, when nothing but the application root is in the URL, maps directly
to the index view. Mapping directly to a view makes sense for pages that don’t
need any data; for example, you might use this for an About page. Last of all,
we have the 500 error mapping.
Let’s add another mapping that will match the URLs that we want to support.
The code in grails-app/conf/UrlMappings.groovy should look something like this:

        "/events/$nickname"{
            controller = "tekEvent"
            action = "show"
        }

The default Grails mapping uses all variables. Our mapping is using a static
value ( events ) and a variable ( $nickname ). Since our mapping does not include
variables for controller and action , we need to set those inside the mapping block.
This mapping will match any URL that starts with the word events and has
one more value, which will be assigned to the variable $nickname . The matched
URL will be directed to the show action of TekEventController with a nickname
parameter. So, now we need our controller to make use of the nickname .
We’re going to modify the show action to use a nickname parameter to show a
TekEvent instance. Before we do that, though, we need to add a nickname to
TekEvent . In TekDays/grails-app/domain/com/tekdays/TekEvent.groovy , add the two high-
lighted lines below:

package com.tekdays
class TekEvent {
    String city
    String name
    TekUser organizer
    String venue
    Date startDate
    Date endDate
    String description
-->    String nickname
    String toString(){
      "$name, $city"
    }

    static searchable = true
    static hasMany = [volunteers : TekUser,
                      respondents : String,
                      sponsorships : Sponsorship,
                      tasks : Task,
                      messages : TekMessage]
    static constraints = {
        name()
        city()
        description maxSize: 5000
        organizer()
        venue()
        startDate()
        endDate()
        volunteers nullable: true
        sponsorships nullable: true
        tasks nullable: true
        messages nullable: true
-->        nickname nullable: true
    }
}

 
Now that we have that property, let’s get to work. Open TekDays/grails-app/con-
trollers/com/tekdays/TekEventController.groovy , and modify the show action like this:

This action’s job is to pass a TekEvent instance to the show view. Here, we’re
beginning the action by declaring the tekEventInstance , and we’re giving the
action two different ways to retrieve it: by its id or by its nickname . To do this,
we separate the variable declaration from the assignment. We use an if to
decide whether to retrieve the instance by nickname or by id . If there’s a nickname
value in the params , we use the dynamic finder findByNickname() . Then, to make
our error messages clearer in case we don’t find an instance, we use another
if block to determine the appropriate error message to display.
We added the nickname of “GatewayCode” to one of our test events, so now
we can navigate to http://localhost:8080/TekDays/events/GatewayCode to view the home
page of the event.


